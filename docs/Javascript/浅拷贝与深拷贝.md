### 浅拷贝与深拷贝

#### 一、浅拷贝

浅拷贝是指创建一个新对象，然后将原对象中的属性复制到新对象中。如果原对象的属性是**基本数据类型**，那么浅拷贝会直接复制这些值；但如果原对象的属性是**引用类型**，那么浅拷贝只会复制这些引用，导致新对象和原对象共享同一个引用。

**示例：**

```javascript
const original = {
  name: "Alice",
  hobbies: ["reading", "gaming"]
};

const shallowCopy = { ...original };

shallowCopy.name = "Bob"; // 修改基本类型属性
shallowCopy.hobbies.push("cooking"); // 修改引用类型属性

console.log(original.name); // Alice
console.log(original.hobbies); // ["reading", "gaming", "cooking"]
```

在这个示例中，`name` 属性的修改不会影响原对象，但 `hobbies` 属性的修改会影响原对象，因为它们共享同一个数组引用。

#### 二、深拷贝

深拷贝是指创建一个新对象，并递归地复制原对象的所有属性，无论是基本数据类型还是引用类型。深拷贝确保新对象与原对象之间完全独立，任何一方的修改都不会影响另一方。

**示例：**

```javascript
const original = {
  name: "Alice",
  hobbies: ["reading", "gaming"]
};

// 使用 JSON 方法进行深拷贝
const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.name = "Bob"; // 修改基本类型属性
deepCopy.hobbies.push("cooking"); // 修改引用类型属性

console.log(original.name); // Alice
console.log(original.hobbies); // ["reading", "gaming"]
```

在这个示例中，深拷贝确保了 `original` 对象不会受到 `deepCopy` 对象的影响。

另外一种实现方法(**递归**)

```javascript
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item));
    }
    const newObj = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            newObj[key] = deepClone(obj[key]);
        }
    }
    return newObj;
}
```



#### 三、总结

- **浅拷贝**：仅复制对象的第一层属性，对于引用类型属性，复制的是引用，原对象和拷贝对象共享这些引用。
- **深拷贝**：递归复制所有层级的属性，确保原对象和拷贝对象完全独立。
