{
  "blogPosts": [
    {
      "id": "新Mac安装指南",
      "metadata": {
        "permalink": "/en/blog/新Mac安装指南",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-03-30-新Mac安装指南.md",
        "source": "@site/blog/2025-03-30-新Mac安装指南.md",
        "title": "新Mac安装指南",
        "description": "1 . Chrome",
        "date": "2025-03-30T00:00:00.000Z",
        "formattedDate": "March 30, 2025",
        "tags": [
          {
            "label": "other",
            "permalink": "/en/blog/tags/other"
          }
        ],
        "readingTime": 0.4,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "新Mac安装指南",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "新Mac安装指南",
          "title": "新Mac安装指南",
          "authors": {
            "name": "时雨",
            "title": "新Mac安装指南",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "other"
          ]
        },
        "nextItem": {
          "title": "面试笔记",
          "permalink": "/en/blog/面试笔记"
        }
      },
      "content": "1 . Chrome\n\n2 . ClashX\n\n3 . Raycast\n\n4 . VS Code & Cursor\t\t\t\n\n5 . Typora\n\n6 . XCode (command line tools)\n\n7 . Homebrew\n\n8 . Git\n\n9 . oh my zsh\n\n​\tExtension: `git`  `zsh-autosuggestions`  `zsh-completions`  `fast-syntax-highlighting`\n\n10 . node, npm, nvm, pnpm \n\n\n\nn . 配置\n\n1 .将截图保存到桌面\n\n```\ndefaults write com.apple.screencapture location ~/Desktop\t\n```\n\n2.在setting里提高光标响应速率\n![keyboardShow](/Blog_img/keyboardShow.jpg)"
    },
    {
      "id": "面试笔记",
      "metadata": {
        "permalink": "/en/blog/面试笔记",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-02-16-面试.md",
        "source": "@site/blog/2025-02-16-面试.md",
        "title": "面试笔记",
        "description": "解释下HTML5语义化标签的含义和用法",
        "date": "2025-02-16T00:00:00.000Z",
        "formattedDate": "February 16, 2025",
        "tags": [
          {
            "label": "other",
            "permalink": "/en/blog/tags/other"
          }
        ],
        "readingTime": 107.755,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "面试笔记",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "面试笔记",
          "title": "面试笔记",
          "authors": {
            "name": "时雨",
            "title": "面试笔记",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "other"
          ]
        },
        "prevItem": {
          "title": "新Mac安装指南",
          "permalink": "/en/blog/新Mac安装指南"
        },
        "nextItem": {
          "title": "git撤回操作指南",
          "permalink": "/en/blog/git撤回操作指南"
        }
      },
      "content": "#### 解释下HTML5语义化标签的含义和用法\n\nheader footer nav ..\n\n便于SEO搜索引擎优化 以及 无障碍阅读\n\n#### html5的新特性\n\nHTML5 不仅引入了语义化标签，还包括许多其他特性和改进，以下是一些重要的 HTML5 特性：\n\n### 1. 新的表单控件和属性\nHTML5 添加了许多新的表单控件和属性，增强了表单的功能和用户体验。\n\n- **日期选择控件**\n\n  ```html\n  <input type=\"date\">\n  ```\n\n- **颜色选择控件**\n\n  ```html\n  <input type=\"color\">\n  ```\n\n- **范围选择控件**\n\n  ```html\n  <input type=\"range\" min=\"0\" max=\"100\">\n  ```\n\n- **电子邮件和 URL 验证**\n\n  ```html\n  <input type=\"email\">\n  <input type=\"url\">\n  ```\n\n- **占位符**\n\n  ```html\n  <input type=\"text\" placeholder=\"请输入文本\">\n  ```\n\n### 2. 音频和视频支持\nHTML5 通过 `<audio>` 和 `<video>` 标签提供了对音频和视频的原生支持，无需第三方插件。\n\n- **音频**\n\n- **视频**\n\n  \n\n### 3. 本地存储\nHTML5 提供了本地存储机制，可以在客户端存储数据。\n\n- **localStorage**\n\n  ```javascript\n  localStorage.setItem('key', 'value');\n  var value = localStorage.getItem('key');\n  ```\n\n- **sessionStorage**\n\n  ```javascript\n  sessionStorage.setItem('key', 'value');\n  var value = sessionStorage.getItem('key');\n  ```\n\n### 4. 画布 (Canvas)\n\n\n\n\n### 前端缓存\n\n浏览器缓存、HTTP缓存和Web Storage都是用于在客户端存储数据以提高性能和用户体验的技术，但它们在实现方式、使用场景和持久性方面有一些区别。下面是它们的详细介绍和对比。\n\n### 浏览器缓存（Browser Cache）\n\n浏览器缓存是一种存储机制，用于保存静态资源（如HTML、CSS、JavaScript、图像等），以减少对服务器的重复请求，提升网页加载速度。\n\n- **工作原理**：当浏览器请求资源时，会首先检查本地缓存是否有该资源的有效副本。如果有，则直接从缓存中读取资源，而不是向服务器请求。\n- **控制方式**：通过HTTP头部（如Cache-Control、Expires、ETag、Last-Modified）来控制资源的缓存行为和过期时间。\n- **用途**：减少服务器负载、加快页面加载速度。\n\n### 强缓存 200 不向服务端发请求\n\n- **Cache-Control**：一个常用的HTTP头，用于指定缓存指令。例如：\n  ```http\n  Cache-Control: max-age=3600, must-revalidate\n  ```\n  表示资源在缓存中可以保存3600秒，但在使用前必须验证其有效性。\n\n- **Expires**：指定资源的过期时间，是一个绝对时间点。例如：\n  ```http\n  Expires: Wed, 21 Oct 2023 07:28:00 GMT\n  ```\n\n#### 协商: 304 向服务端发请求 转到缓存304\n\n- **ETag**：一个唯一标识符，用于标识资源的版本。当资源更新时，ETag也会更新。例如：\n\n  ```http\n  ETag: \"34aa387-d-1568eb00\"\n  ```\n\n- **Last-Modified**：表示资源的最后修改时间。例如：\n  ```http\n  Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT\n  ```\n\n### 1. 强缓存 `Expires` 和 `Cache-Control`\n\n- **Expires**：指定资源过期的绝对时间。浏览器在该时间前都直接从缓存读取资源。\n\n  ```\n  Expires: Wed, 21 Oct 2023 07:28:00 GMT\n  ```\n  \n- **Cache-Control**：提供更细粒度的控制。常用的指令有 `max-age`、`public`、`private`、`no-cache` 和 `no-store`。\n\n  ```\n  Cache-Control: max-age=3600, public\n  ```\n\n### 2. 协商缓存 `ETag` 和 `Last-Modified`\n\n- **ETag**：服务器生成的资源标识符。浏览器在请求时会带上 `If-None-Match` 头部，服务器通过比较 ETag 判断资源是否更新。\n\n  ```\n  ETag: \"34aa387-d-1568eb00\"\n  ```\n  \n- **Last-Modified**：资源的最后修改时间。浏览器在请求时会带上 `If-Modified-Since` 头部，服务器通过比较时间判断资源是否更新。\n\n  ```\n  Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT\n  ```\n\n\n\n\n\n##### localStorage 和 sessionStorage 和 cookie\n\nlocalStorage 和 sessionStorage 是HTML5的新特性, 之前使用cookie.\n\n优点：不会随着HTTP请求发向服务器,减轻负载\n\nwebStorage 不会随着HTTP发到服务器 cookie会发送 大概2KB\n\nlcoalStorgae 储存在本地\n\nsession在会话 关闭浏览器会消除\n\n##### 前端可以储存cookie吗\n\n可以 \t\t\tdocument.cookie  = \n\n\n\n# CSS\n\n **flex:1 是什么意思**\n\nFlex-grow:1 flex-shrink:0 flex-basis: 0%\n\n##### css两种盒子模型 box-sizing\n\n1. content-box: 总宽度= 两边boarder + content(width:200px) + 两边padding\n2. boarder-box 总宽度(200px) = 涵盖了 两边boarder + content + 两边padding\n\n\n\n##### margin padding参数的顺序\n\n```\n上下20px\t\t左右10px\nmargin: 20px 10px \n上20px 左右10px \t下30px\nmargin: 20px 10px 30px;\n上20px 右10px 下30px 左40px 顺时针\nmargin:  20px 10px 30px 40px;\n```\n\n##### display:none |  visibility: hidden | opacity:0的区别\n\n- **`display: none`**：元素不占空间，无法交互。\n- **`visibility: hidden`**：元素占空间，但不可见，无法交互。\n- **`opacity: 0`**：元素完全透明，仍占空间并可以交互。\n\n\n\nposition:absolute的定位: 通过指定元素相对于最近的**非 static** 定位祖先元素,父元素都没写 相当于**视口**\n\nposition:fixed 通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置\n\n\n\n### 水平垂直居中实现\n\n### \tflex布局\n\n```html\n<style>\n.content{\n    display: flex;\n    height: 100vh;\n    justify-content: center;\n    align-items: center;\n}\n.box{\n    height: 100px;\n    width: 100px;\n    background-color: blue;\n}\n</style>   \n<body>\n    <div class=\"content\">\n        <div class=\"box\"></div>\n    </div>\n</body>\n```\n\n### flex布局 margin：auto\n\n###        绝对定位\n\n```html\n<style>\n  .content{\n      height: 100vh;\n      position: relative;\n  }\n  .box{\n      position: absolute;\n      top: 50%;\n      left: 50%;\n      transform: translate(-50%, -50%); // 将正方形平移 使在最中心\n      height: 100px;\n      width: 100px;\n      background-color: blue;\n  }\n</style>      \n\n<body>\n    <div class=\"content\">\n        <div class=\"box\"></div>\n    </div>\n</body>\n```\n\n网格居中\n\n```css\ndisplay: grid;\njustify-items: center; /* Horizontal centering */\nalign-items: center; /* Vertical centering */\n```\n\n\n\n\n\n\n\n### 网格模型\n\n```html\n<style>\n      .grid-container {\n      display: grid;\n      grid-template-columns: repeat(3, 1fr);\n      grid-template-rows: auto;\n      gap: 10px;\n      padding: 10px;\n      background-color: #f0f0f0;\n    }\n\n    .grid-item {\n      background-color: #4caf50;\n      color: white;\n      padding: 20px;\n      text-align: center;\n      font-size: 1.5em;\n      border-radius: 5px;\n    }\n</style>\n\n<div class=\"grid-container\">\n  <div class=\"grid-item\">1</div>\n  <div class=\"grid-item\">2</div>\n  <div class=\"grid-item\">3</div>\n  <div class=\"grid-item\">4</div>\n  <div class=\"grid-item\">5</div>\n  <div class=\"grid-item\">6</div>\n</div>\n```\n\n\n\n####  **左侧固定** **右侧自适应**\n\n父元素**display flex**\n\n左侧**500px** 右侧**flex:1**\n\n\n\n#### rem\n\n`rem`（root em）是一种相对长度单位，常用于 CSS 中来实现响应式设计和可访问性。它的值相对于根元素的字体大小（即 HTML 元素的字体大小），而不是相对于当前元素的字体大小。\n\n### 1. 基本概念\n\n- **rem**：相对于根元素（`<html>`）的字体大小。\n- **em**：相对于当前元素的字体大小。\n\n### 2. 默认值\n\n默认情况下，根元素的字体大小通常为 16 像素。\n\n### 3. 使用示例\n\n#### 基本用法\n\n```css\nhtml {\n  font-size: 16px; /* 默认大小 */\n}\n\nbody {\n  font-size: 1rem; /* 16px */\n}\n\nh1 {\n  font-size: 2rem; /* 32px */\n}\n\np {\n  font-size: 0.875rem; /* 14px */\n}\n```\n\n#### 调整根字体大小\n\n通过调整根元素的字体大小，可以实现响应式设计。例如，使用媒体查询来调整根字体大小：\n\n```css\nhtml {\n  font-size: 16px; /* 默认大小 */\n}\n\n@media (min-width: 768px) {\n  html {\n    font-size: 18px; /* 大屏设备上的字体大小 */\n  }\n}\n\n@media (min-width: 1024px) {\n  html {\n    font-size: 20px; /* 更大屏设备上的字体大小 */\n  }\n}\n\nbody {\n  font-size: 1rem; /* 根据根字体大小变化 */\n}\n\nh1 {\n  font-size: 2rem;\n}\n\np {\n  font-size: 0.875rem;\n}\n```\n\n在这个示例中，当屏幕宽度达到 768 像素时，根字体大小变为 18 像素；当屏幕宽度达到 1024 像素时，根字体大小变为 20 像素。这样可以实现响应式的字体大小调整。\n\n### 4. rem 与 em 的区别\n\n- **rem**：相对于根元素的字体大小，具有全局一致性。无论元素嵌套层次如何，其值都保持一致。\n- **em**：相对于当前元素的字体大小，具有局部继承性。嵌套元素会继承其父元素的字体大小，并相对调整。\n\n#### em 示例\n\n```css\n.parent {\n  font-size: 16px;\n}\n\n.child {\n  font-size: 2em; /* 32px，因为父元素的字体大小是 16px */\n}\n\n.grandchild {\n  font-size: 0.5em; /* 16px，因为父元素的字体大小是 32px */\n}\n```\n\n在这个示例中，`.child` 元素的字体大小是 32 像素（2em），而 `.grandchild` 元素的字体大小是 16 像素（0.5em），这是因为 `em` 是相对当前元素的字体大小计算的。\n\n### 5. rem 的优点\n\n- **一致性**：由于 `rem` 是相对于根元素的字体大小，所以在整个文档中保持一致性和可预测性。\n- **可访问性**：通过调整根元素的字体大小，可以全局调整页面的所有字体大小，这对于实现响应式设计和提高可访问性非常有用。\n- **简化计算**：使用 `rem` 可以避免嵌套元素的字体大小层层叠加计算，简化了 CSS 的维护。\n\n\n\n# JS \n\n### ES6新特性\n\n### 1. 块级作用域和变量声明\n#### `let` 和 `const`\n- `let` 用于声明块级作用域的变量。\n- `const` 用于声明常量，值一旦赋值后不能再修改。\n\n```javascript\nlet a = 10;\nconst b = 20;\n\nif (true) {\n    let a = 30;\n    const b = 40;\n    console.log(a); // 30\n    console.log(b); // 40\n}\n\nconsole.log(a); // 10\nconsole.log(b); // 20\n```\n\n### 2. 箭头函数\n简洁的函数语法，且不绑定 `this` 箭头函数的this是上下文的this\n\n箭头函数没有自己的 `arguments` 对象\n\n箭头函数不能用作构造函数(比如 function Person)，尝试使用 `new` 会抛出错误(const p = new Person 需要普通函数)\n\n```javascript\nconst add = (x, y) => x + y;\nconsole.log(add(2, 3)); // 5\n```\n\n### 3. 模板字符串\n多行字符串和嵌入表达式的语法。\n\n```javascript\nconst name = 'John';\nconst greeting = `Hello, ${name}!`;\nconsole.log(greeting); // Hello, John!\n```\n\n### 4. 解构赋值\n从数组或对象中提取值，并将其分配给变量。\n\n```javascript\n// 数组解构\nlet [a, b] = [1, 2];\nconsole.log(a); // 1\nconsole.log(b); // 2\n\n// 对象解构\nconst obj = { name: 'John', age: 30 };\nlet { name, age } = obj;\nconsole.log(name); // John\nconsole.log(age); // 30\n```\n\n### 5. 扩展运算符\n```javascript\n// 数组展开\nlet arr = [1, 2, 3];\nlet newArr = [...arr, 4, 5];\nconsole.log(newArr); // [1, 2, 3, 4, 5]\n\n// 对象展开\nlet obj1 = { a: 1, b: 2 };\nlet obj2 = { ...obj1, c: 3 };\nconsole.log(obj2); // { a: 1, b: 2, c: 3 }\n```\n\n### 6. 类（Classes）\nES6 引入了基于原型的继承的类语法糖。\n\n```javascript\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    greet() {\n        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n    }\n}\n\nconst john = new Person('John', 30);\njohn.greet(); // Hello, my name is John and I am 30 years old.\n```\n\n#### 问: 你说的这个我不是很理解 以前的js没有类这个概念吗 还是只是没有语法糖\n\n在 ES6（ECMAScript 2015）之前，JavaScript 确实没有类（class）的语法，但它仍然支持面向对象编程，通过使用函数和原型链来实现继承和对象创建。ES6 引入了类的语法糖，使得定义和继承类的语法更加简洁和易读，但实际上，这些类的底层机制仍然基于原型。\n\n#### ES6 之前的面向对象编程\n\n在 ES6 之前，我们通常通过构造函数和原型链来创建对象和实现继承：\n\n##### 构造函数和原型链\n\n```javascript\n// 构造函数\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\n// 在原型上添加方法\nPerson.prototype.greet = function() {\n    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n};\n\nconst john = new Person('John', 30);\njohn.greet(); // Hello, my name is John and I am 30 years old.\n```\n\n##### 继承\n\n```javascript\nfunction Student(name, age, grade) {\n    // 调用父类构造函数\n    Person.call(this, name, age);\n    this.grade = grade;\n}\n\n// 设置继承关系\nStudent.prototype = Object.create(Person.prototype);\nStudent.prototype.constructor = Student;\n\n// 在子类原型上添加方法\nStudent.prototype.study = function() {\n    console.log(`${this.name} is studying in grade ${this.grade}.`);\n};\n\nconst jane = new Student('Jane', 22, 'A');\njane.greet(); // Hello, my name is Jane and I am 22 years old.\njane.study(); // Jane is studying in grade A.\n```\n\n#### ES6 类语法\n\nES6 引入了 `class` 关键字，这是一种更加简洁和直观的定义类和继承的方式。尽管语法上看起来像是面向对象编程语言中的类，但底层仍然使用原型链机制。\n\n#### 定义类\n\n```javascript\nclass Person {\n    constructor(name, age) {\n        this.name = name;\n        this.age = age;\n    }\n\n    greet() {\n        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);\n    }\n}\n\nconst john = new Person('John', 30);\njohn.greet(); // Hello, my name is John and I am 30 years old.\n```\n\n#### 类继承\n\n```javascript\nclass Student extends Person {\n    constructor(name, age, grade) {\n        super(name, age); // 调用父类的构造函数\n        this.grade = grade;\n    }\n\n    study() {\n        console.log(`${this.name} is studying in grade ${this.grade}.`);\n    }\n}\n\nconst jane = new Student('Jane', 22, 'A');\njane.greet(); // Hello, my name is Jane and I am 22 years old.\njane.study(); // Jane is studying in grade A.\n```\n\n### 总结\n\n- **ES6 之前**：通过构造函数和原型链来实现对象创建和继承。这种方式虽然灵活，但语法较为复杂和冗长。\n- **ES6 之后**：引入了类的语法糖，使得定义类和继承更加直观和简洁，但本质上仍然基于原型机制。\n\n### 7. 模块（Modules）\n\nes6相比cjs在模块化上提升\n\n#####  静态分析\n\n- **ES6**：模块是**静态**的，导入和导出语句在编译时就能确定。这使得工具能够在编译阶段进行静态分析，有助于优化和提升性能。\n- **CJS**：模块是**动态**的，导入和导出在运行时确定，导致静态分析的难度增加\n\n\n\n### 8. Promise\n用于处理异步操作。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve('Success!'), 1000);\n});\n\npromise.then(result => console.log(result)); // 1秒后输出: Success!\n```\n\n三个状态（pending fulfilled rejected）\n\n方法 then catch finally\n\n### 9. 默认参数\n\n为函数参数设置默认值。\n\n```javascript\nfunction greet(name = 'Guest') {\n    console.log(`Hello, ${name}!`);\n}\n\ngreet(); // Hello, Guest!\ngreet('John'); // Hello, John!\n```\n\n### 10. for...of 循环\n用于遍历可迭代对象（如数组、字符串等）。\n\n```javascript\nlet arr = [1, 2, 3];\nfor (let value of arr) {\n    console.log(value); // 1, 2, 3\n}\n```\n\n\n\n\n\n\n\n\n\n### 数组的常用方法\n\nJavaScript 中的数组对象提供了多种方法来操作和处理数组。以下是一些常用的数组方法及其简单示例：\n\n### 1. 创建数组\n\n#### `Array.from()`\n从类数组或可迭代对象创建一个新的数组实例。\n\n```javascript\nconst arr = Array.from('hello');\nconsole.log(arr); // 输出: ['h', 'e', 'l', 'l', 'o']\n```\n\n### 2. 添加和删除元素\n\n#### `push()`\n在数组末尾添加一个或多个元素，返回数组的新长度。\n\n```javascript\nconst arr = [1, 2, 3];\narr.push(4);\nconsole.log(arr); // 输出: [1, 2, 3, 4]\n```\n\n#### `pop()`\n移除数组中的最后一个元素，返回该元素。\n\n```javascript\nconst arr = [1, 2, 3, 4];\narr.pop();\nconsole.log(arr); // 输出: [1, 2, 3]\n```\n\n#### `unshift()`\n在数组的开头添加一个或多个元素，返回数组的新长度。\n\n```javascript\nconst arr = [1, 2, 3];\narr.unshift(0);\nconsole.log(arr); // 输出: [0, 1, 2, 3]\n```\n\n#### `shift()`\n移除数组中的第一个元素，返回该元素。\n\n```javascript\nconst arr = [1, 2, 3];\narr.shift();\nconsole.log(arr); // 输出: [2, 3]\n```\n\n#### `splice()`\n通过删除或替换现有元素和/或添加新元素来更改一个数组的内容。\n\n```javascript\nconst arr = [1, 2, 3, 4];\narr.splice(2, 1, 'a', 'b');\nconsole.log(arr); // 输出: [1, 2, 'a', 'b', 4]\n```\n\n### 3. 访问元素\n\n#### `includes()`\n判断数组是否包含某个元素，返回布尔值。\n\n```javascript\nconst arr = [1, 2, 3];\nconsole.log(arr.includes(2)); // 输出: true\nconsole.log(arr.includes(4)); // 输出: false\n```\n\n#### `indexOf()`\n返回数组中首次出现的指定元素的索引，如果不存在则返回 -1。\n\n```javascript\nconst arr = [1, 2, 3, 2];\nconsole.log(arr.indexOf(2)); // 输出: 1\nconsole.log(arr.indexOf(4)); // 输出: -1\n```\n\n#### `lastIndexOf()`\n返回数组中最后出现的指定元素的索引，如果不存在则返回 -1。\n\n```javascript\nconst arr = [1, 2, 3, 2];\nconsole.log(arr.lastIndexOf(2)); // 输出: 3\nconsole.log(arr.lastIndexOf(4)); // 输出: -1\n```\n\n### 4. 迭代方法\n\n#### `forEach()`\n对数组中的每个元素执行一次提供的函数。\n\n```javascript\nconst arr = [1, 2, 3];\narr.forEach((element) => {\n    console.log(element);\n});\n// 输出:\n// 1\n// 2\n// 3\n```\n\n#### `map()`\n创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。\n\n```javascript\nconst arr = [1, 2, 3];\nconst mappedArr = arr.map((element) => element * 2);\nconsole.log(mappedArr); // 输出: [2, 4, 6]\n```\n\n#### `filter()`\n创建一个新数组，其中包含所有通过提供函数测试的元素。\n\n```javascript\nconst arr = [1, 2, 3, 4];\nconst filteredArr = arr.filter((element) => element % 2 === 0);\nconsole.log(filteredArr); // 输出: [2, 4]\n```\n\n#### `reduce()`\n对数组中的每个元素执行一个提供的函数，将其结果汇总为单个返回值。\n\n```javascript\nconst arr = [1, 2, 3, 4];\nconst sum = arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\nconsole.log(sum); // 输出: 10\n```\n\n#### `every()`\n测试数组中的所有元素是否都通过了提供的函数的测试，返回布尔值。\n\n```javascript\nconst arr = [1, 2, 3, 4];\nconst allEven = arr.every((element) => element % 2 === 0);\nconsole.log(allEven); // 输出: false\n```\n\n#### `some()`\n测试数组中的至少一个元素是否通过了提供的函数的测试，返回布尔值。\n\n```javascript\nconst arr = [1, 2, 3, 4];\nconst someEven = arr.some((element) => element % 2 === 0);\nconsole.log(someEven); // 输出: true\n```\n\n### 5. 查找元素\n\n#### `find()`\n返回数组中满足提供的测试函数的第一个元素的值，否则返回 `undefined`。\n\n```javascript\nconst arr = [1, 2, 3, 4];\nconst found = arr.find((element) => element > 2);\nconsole.log(found); // 输出: 3\n```\n\n#### `findIndex()`\n返回数组中满足提供的测试函数的第一个元素的索引，否则返回 -1。\n\n```javascript\nconst arr = [1, 2, 3, 4];\nconst index = arr.findIndex((element) => element > 2);\nconsole.log(index); // 输出: 2\n```\n\n### 6. 连接和切片\n\n#### `concat()`\n合并两个或多个数组，不改变现有数组，返回一个新数组。\n\n```javascript\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconst combinedArr = arr1.concat(arr2);\nconsole.log(combinedArr); // 输出: [1, 2, 3, 4]\n```\n\n#### `join()`\n将数组的所有元素连接成一个字符串。\n\n```javascript\nconst arr = [1, 2, 3];\nconst str = arr.join('-');\nconsole.log(str); // 输出: \"1-2-3\"\n```\n\n#### `slice()`\n返回一个新数组，包含从开始索引到结束索引（不包括结束索引）的数组元素。\n\n```javascript\nconst arr = [1, 2, 3, 4];\nconst slicedArr = arr.slice(1, 3);\nconsole.log(slicedArr); // 输出: [2, 3]\n```\n\n#### `flat()`\n按指定深度递归地将数组展平，并返回一个新数组。\n\n```javascript\nconst arr = [1, [2, [3, [4]]]];\nconst flattenedArr = arr.flat(2);\nconsole.log(flattenedArr); // 输出: [1, 2, 3, [4]]\n```\n\n#### `flatMap()`\n先对数组中的每个元素执行一个提供的函数，然后将结果压缩成一个新数组。\n\n```javascript\nconst arr = [1, 2, 3];\nconst flatMappedArr = arr.flatMap(x => [x, x * 2]);\nconsole.log(flatMappedArr); // 输出: [1, 2, 2, 4, 3, 6]\n```\n\n### 7. 排序和反转\n\n#### `sort()`\n对数组中的元素进行原地排序并返回该数组。\n\n```javascript\nconst arr = [3, 1, 4, 1, 5];\narr.sort((a, b) => a - b);\nconsole.log(arr); // 输出: [1, 1, 3, 4, 5]\n```\n\n#### `reverse()`\n将数组中的元素原地反转，并返回该数组。\n\n```javascript\nconst arr = [1, 2, 3];\narr.reverse();\nconsole.log(arr); // 输出: [3, 2, 1]\n```\n\n### 8. 其他方法\n\n#### `fill()`\n用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。\n\n```javascript\nconst arr = [1, 2, 3, 4];\narr.fill(0, 1, 3);\nconsole.log(arr); // 输出: [1, 0, 0, 4]\n``\n```\n\n\n\n### ES6新特性\n\nECMAScript 6 (ES6)，也称为 ECMAScript 2015，是JavaScript的一次重要更新，带来了许多新特性和改进。以下是一些主要的新特性：\n\n1. **let 和 const 声明**：\n   - `let`：用于声明块级作用域变量。\n   - `const`：用于声明常量，值一旦赋值就不能再修改。\n\n   ```javascript\n   let x = 10;\n   const y = 20;\n   ```\n\n2. **箭头函数**：\n   - 简洁的函数定义方式，并且不绑定自己的 `this`。\n\n   ```javascript\n   const add = (a, b) => a + b;\n   ```\n\n3. **模板字符串**：\n   - 使用反引号 (`) 包含字符串，可以嵌入表达式和多行字符串。\n\n   ```javascript\n   const name = 'John';\n   const greeting = `Hello, ${name}!`;\n   ```\n\n4. **解构赋值**：\n   - 可以从数组或对象中提取值，并赋值给变量。\n\n   ```javascript\n   // 数组解构\n   const [a, b] = [1, 2];\n   // 对象解构\n   const {name, age} = {name: 'John', age: 30};\n   ```\n   \n5. **默认参数**：\n   - 函数参数可以有默认值。\n\n   ```javascript\n   function greet(name = 'Guest') {\n       return `Hello, ${name}!`;\n   }\n   ```\n\n6. **扩展运算符和剩余参数**：\n   - 扩展运算符用于展开数组或对象。\n   - 剩余参数用于将多个参数合并为一个数组。\n\n   ```javascript\n   // 扩展运算符\n   const arr = [1, 2, ...[3, 4]];\n   \n   // 剩余参数\n   function sum(...numbers) {\n       return numbers.reduce((acc, num) => acc + num, 0);\n   }\n   ```\n\n7. **对象字面量的简写**：\n   - 简化对象属性和方法的定义。\n\n   ```javascript\n   const name = 'John';\n   const person = {\n       name,\n       greet() {\n           console.log('Hello!');\n       }\n   };\n   ```\n\n8. **类 (Class)**：\n   - 基于原型的面向对象编程语法糖。\n\n   ```javascript\n   class Person {\n       constructor(name) {\n           this.name = name;\n       }\n       greet() {\n           console.log(`Hello, ${this.name}!`);\n       }\n   }\n   ```\n\n9. **模块 (Modules)**：\n   - 用于模块化JavaScript代码，使用 `import` 和 `export` 关键字。\n\n   ```javascript\n   // 导出模块\n   export const name = 'John';\n   export function greet() {\n       console.log('Hello!');\n   }\n   \n   // 导入模块\n   import {name, greet} from './module.js';\n   ```\n\n10. **Promise**：\n    - 用于处理异步操作。\n\n    ```javascript\n    const promise = new Promise((resolve, reject) => {\n        setTimeout(() => resolve('Done!'), 1000);\n    });\n    \n    promise.then(result => console.log(result));\n    ```\n\n这些特性使得JavaScript更强大、更简洁，也更易于编写和维护。\n\n\n\n## 变量提升 基本数据类型 函数 函数表达式(箭头函数) 类\n\nJavaScript 的变量提升（Hoisting）是一个概念，它指的是变量和函数声明在编译阶段被提升到其所在作用域的顶部，但初始化操作不会提升。不同的声明方式（`var`, `let`, `const`），以及函数声明和类声明的提升行为各有不同。\n\n### 1. `var` 的变量提升\n\n使用 `var` 声明的变量会被提升到其所在函数或全局作用域的顶部，但不会被初始化。\n\n```javascript\nconsole.log(a); // 输出: undefined\nvar a = 10;\nconsole.log(a); // 输出: 10\n```\n\n上面的代码相当于：\n\n```javascript\nvar a;\nconsole.log(a); // 输出: undefined\na = 10;\nconsole.log(a); // 输出: 10\n```\n\n### 2. `let` 和 `const` 的变量提升\n\n`let` 和 `const` 声明的变量也会被提升到作用域顶部，但它们在声明之前不能被访问，会出现 `Temporal Dead Zone`（暂时性死区）的错误。\n\n```javascript\nconsole.log(b); // ReferenceError: Cannot access 'b' before initialization\nlet b = 20;\nconsole.log(b); // 输出: 20\n\nconsole.log(c); // ReferenceError: Cannot access 'c' before initialization\nconst c = 30;\nconsole.log(c); // 输出: 30\n```\n\n### 3. 函数声明的提升\n\n函数声明会被提升到其所在作用域的顶部，因此可以在声明之前调用。\n\n```javascript\nconsole.log(add(2, 3)); // 输出: 5\n\nfunction add(x, y) {\n  return x + y;\n}\n```\n\n### 4. 函数表达式的提升\n\n函数表达式中的变量声明会被提升，但赋值不会被提升，因此在声明之前调用会出现错误。\n\n```javascript\nconsole.log(subtract); // 输出: undefined\nconsole.log(subtract(5, 2)); // TypeError: subtract is not a function\n\nvar subtract = function (x, y) {\n  return x - y;\n};\n```\n\n上面的代码相当于：\n\n```javascript\nvar subtract;\nconsole.log(subtract); // 输出: undefined\nconsole.log(subtract(5, 2)); // TypeError: subtract is not a function\n\nsubtract = function (x, y) {\n  return x - y;\n};\n```\n\n### 5. 类的提升\n\n类声明不会被提升，在声明之前使用会导致 `ReferenceError`。\n\n```javascript\nconst instance = new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization\n\nclass MyClass {\n  constructor() {\n    this.name = 'MyClass';\n  }\n}\n```\n\n类表达式的变量声明会被提升，但类本身不会被提升。\n\n```javascript\nconsole.log(MyClass); // 输出: undefined\nconst instance = new MyClass(); // TypeError: MyClass is not a constructor\n\nvar MyClass = class {\n  constructor() {\n    this.name = 'MyClass';\n  }\n};\n```\n\n### 6. 基本数据类型和对象\n\n基本数据类型（如 `number`, `string`, `boolean`, `null`, `undefined`, `symbol`）和对象的声明遵循上述 `var`, `let`, `const` 的变量提升规则。无论是基本数据类型还是对象，它们的声明方式决定了它们的提升行为。\n\n### 变量提升示例\n\n总结上述规则，我们来看一个综合示例：\n\n```javascript\nconsole.log(x); // 输出: undefined\nvar x = 5;\nconsole.log(x); // 输出: 5\n\nconsole.log(y); // ReferenceError: Cannot access 'y' before initialization\nlet y = 10;\nconsole.log(y); // 输出: 10\n\nconsole.log(z); // ReferenceError: Cannot access 'z' before initialization\nconst z = 15;\nconsole.log(z); // 输出: 15\n\nconsole.log(sum(2, 3)); // 输出: 5\nfunction sum(a, b) {\n  return a + b;\n}\n\nconsole.log(multiply); // 输出: undefined\nconsole.log(multiply(2, 3)); // TypeError: multiply is not a function\nvar multiply = function (a, b) {\n  return a * b;\n};\n\nconsole.log(Dog); // 输出: undefined\nconst myDog = new Dog(); // TypeError: Dog is not a constructor\nvar Dog = class {\n  constructor() {\n    this.name = 'Dog';\n  }\n};\n```\n\n### 总结\n\n- `var` 声明的变量会被提升到作用域顶部，但初始化不会提升。\n- `let` 和 `const` 声明的变量会被提升，但在声明之前访问会导致 `ReferenceError`。\n- 函数声明会被提升，可以在声明之前调用。\n- 函数表达式和类声明不会被提升，在声明之前调用会导致错误。\n- 基本数据类型和对象的声明遵循相应的提升规则。\n\n\n\n### 数据扁平化\n\n```js\nconst arr=[[1,2,3],4,5,[6,7,[8,9]]]\nfunction bianping(nums){\n    let res = []\n    for (let i = 0; i < nums.length; i++) {\n        let item = nums[i]\n        Array.isArray(item) ? res=res.concat(bianping(item)) : res.push(item)\n    }\n    return res\n}\n\nfunction bianpingES6(nums){\n    return nums.reduce((res,item) => {\n        return res.concat(Array.isArray(item)? bianping(item) : item)\n    },[])\n}\n\nconsole.log(bianping(arr));\nconsole.log(bianpingES6(arr));\n```\n\n\n\n### **`Object`、`Map` 和 `WeakMap` 的区别**：\n\n| 特性           | `Object`                           | `Map`                                | `WeakMap`                            |\n| -------------- | ---------------------------------- | ------------------------------------ | ------------------------------------ |\n| **键类型**     | 只能是**字符串**或 **`Symbol`**    | 可以是任何类型（包括对象）           | 只能是**对象**类型的引用             |\n| **键的顺序**   | 无保证，按插入顺序遍历             | 有插入顺序保证                       | 无保证                               |\n| **键的弱引用** | 否                                 | 否                                   | 是，键是弱引用，垃圾回收机制可清除   |\n| **键的枚举性** | 可以用 `for...in` 或 `Object.keys` | 可以用 `map.keys()` 获取所有键       | 无法枚举键                           |\n| **键的重复性** | 键不能重复，重复会覆盖             | 键不能重复，重复会覆盖               | 键不能重复，重复会覆盖               |\n| **性能优化**   | 对少量数据处理更高效               | 对大量数据处理更高效                 | 用于特定场景（如缓存，自动内存管理） |\n| **垃圾回收**   | 不会自动处理，必须手动清除         | 不会自动处理，必须手动清除           | 键对象若没有其他引用会被垃圾回收     |\n| **常用场景**   | 通常用于存储常规键值对             | 高效处理复杂映射（支持任何类型的键） | 存储依赖对象的临时数据，避免内存泄漏 |\n|                |                                    |                                      |                                      |\n\n\n\n\n\n### 原型链\n\n```js\nfunction Person(name){\n    this.name = name\n}\n\nconst p1 = new Person('john');\n\nconsole.log(p1.__proto__ === Person.prototype); // true\nconsole.log(Person === p1.__proto__.constructor); // true\nconsole.log(Person.prototype.__proto__ === Object.prototype);// true\n```\n\n\n\n### 执行顺序 和事件循环\n\n事件循环就是执行顺序的理论\n\n1. **调用栈（Call Stack）**：\n   - 调用栈是一个 LIFO（后进先出）的数据结构，用于存储正在执行的函数调用。\n   - 当函数被调用时，它会被添加到调用栈顶部。当函数执行完毕后，它会从调用栈中移除。\n2. **任务队列（Task Queue）**：\n   - 任务队列存储需要在未来执行的任务，通常是由异步操作（如 `setTimeout`、网络请求、事件回调等）引入的。\n   - 当调用栈为空时，事件循环会从任务队列中取出一个任务，并将其放入调用栈中执行。\n3. **微任务队列（Microtask Queue）**：\n   - 微任务队列存储需要在更高优先级下执行的任务，通常是由 `Promise` 等引入的。\n   - 微任务队列中的任务在每个宏任务结束后立即执行。\n\n```\nsetTimeout(()=>{\n    console.log('1')\n},0)\nnew Promise((res)=>{\n    console.log('2');\n    res();\n}).then(()=>{\n    console.log('3')\n})\nconsole.log('4')\n// 2 4 3 1 单单创建一个Promise 是同步的        .then()是异步\n```\n\n**创建 `Promise` 实例**：\n\n- `new Promise((res) => {...})`：这一行代码创建了一个新的 `Promise` 实例，并立即执行传入的执行函数（executor function）。\n- 执行函数中的代码是同步的，所以 `console.log('2')` 会立即执行，输出 `2`。\n- 然后执行 `res()`，这只是将 `Promise` 状态变为 `resolved`，但不会立即执行任何异步操作（如 `.then` 中的回调）。\n\n\n\n### for in for of区别，为什么\n\n主要区别在于前者遍历对象的可枚举**属性名**，而后者遍历可迭代**对象的值**。前者主要用于普通对象，后者用于数组、字符串、`Map`、`Set` 等可迭代对象。\n\n```js\nconst list1 = [22,11,33,44]\nfor(const each of list1){\n    console.log(each); //22 11 33 44\n}\nfor(const index in list1){\n    console.log(index);// 0 1 2 3\n}\nconst obj ={\n    address:'hangzhou',\n    name:'bob'\n}\n\nfor(const key in obj){\n    console.log(key); // address name\n}\n\n// 普通对象不可迭代值 只可迭代键 因为普通对象的key 是无序的\n// for(const value of obj){\n//     console.log(value);\n// }\n\n// 可迭代对象包括数组 string Set Map 因为Map的key是有序的\nconst map = new Map(); // Map(2) { 'address' => 'shanghai', 'name' => 'alice' }\nmap.set('address','shanghai')\nmap.set('name','alice')\nfor(const [key,value] of map){\n    console.log(`${key} : ${value}`); // address : shanghai \n}\n\n```\n\n \n\n### 拷贝\n\n浅： 只复制第一层(两个对象一个地址)\n\n**如果我改成 original.b.c = 20 浅拷贝的copy.b.c 也是20 但是深拷贝就是2**\n\n```js\nconst original = { a: 1, b: { c: 2 } };\nconst copy1 = Object.assign({}, original);\nconst copy2 = { ...original };\n```\n\n深: 复制所有层级的对象(两个obj各自独立)\n\n```js\nconst original = { a: 1, b: { c: 2 } };\nconst copy = JSON.parse(JSON.stringify(original));\nfunction deepClone(obj) {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map(item => deepClone(item));\n    }\n    const clone = {};\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            clone[key] = deepClone(obj[key]);\n        }\n    }\n    return clone;\n}\n```\n\n\n\n\n\n\n\n\n\n## Promise\n\n#### Promise.then的参数\n\n`Promise.prototype.then` 方法是处理 Promise 异步操作的主要方法之一。它可以接受最多两个参数，分别是：\n\n1. **onFulfilled**：在 Promise 被解决（fulfilled）时调用的回调函数。\n2. **onRejected**：在 Promise 被拒绝（rejected）时调用的回调函数。\n\n### 参数详解\n\n1. **onFulfilled**：\n   - **类型**：函数（可选）\n   - **描述**：当 Promise 状态变为 fulfilled 时被调用。该函数接受一个参数，即由 Promise resolve 时传递的值。\n   - **返回值**：该函数可以返回一个值，这个值会被包裹在一个新的 Promise 中。如果返回的是一个 Promise，则会等待这个 Promise 被解决后，新的 Promise 才会被解决。\n\n2. **onRejected**：\n   - **类型**：函数（可选）\n   - **描述**：当 Promise 状态变为 rejected 时被调用。该函数接受一个参数，即由 Promise reject 时传递的原因（通常是一个错误对象）。\n   - **返回值**：该函数可以返回一个值，这个值会被包裹在一个新的 Promise 中。如果返回的是一个 Promise，则会等待这个 Promise 被解决后，新的 Promise 才会被解决。如果没有提供这个回调函数或者该回调函数返回一个新的 Promise，链式调用中的下一个 `then` 会接收到这个新的 Promise 的结果。\n\n### 使用示例\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  const success = true; // 假设这是异步操作的结果\n  if (success) {\n    resolve('Operation successful!');\n  } else {\n    reject('Operation failed!');\n  }\n});\n\npromise.then(\n  (value) => {\n    console.log('Fulfilled:', value);\n    // 这里可以返回一个新的值或者 Promise\n    return 'New value';\n  },\n  (error) => {\n    console.log('Rejected:', error);\n  }\n).then(\n  (value) => {\n    console.log('Next fulfillment:', value); // 这里接收到上一个 then 返回的 'New value'\n  },\n  (error) => {\n    console.log('Next rejection:', error);\n  }\n);\n```\n\n### 链式调用\n\n`then` 方法返回一个新的 Promise，这使得链式调用成为可能。每个 `then` 中的 `onFulfilled` 和 `onRejected` 回调函数都会影响后续的 Promise 链。\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  resolve('First success');\n});\n\npromise\n  .then((value) => {\n    console.log('First then:', value);\n    return 'Second success';\n  })\n  .then((value) => {\n    console.log('Second then:', value);\n  });\n```\n\n### 错误处理\n\n通过提供 `onRejected` 回调函数，你可以处理 Promise 被拒绝的情况。如果不提供 `onRejected` 回调函数，可以使用 `catch` 方法来处理错误：\n\n```javascript\nconst promise = new Promise((resolve, reject) => {\n  reject('Something went wrong');\n});\n\npromise\n  .then(\n    (value) => {\n      console.log('Fulfilled:', value);\n    },\n    (error) => {\n      console.error('Rejected:', error);\n    }\n  )\n  .catch((error) => {\n    console.error('Caught by catch:', error);\n  });\n```\n\n手写race\n\n```js\nfunction promiseRace(promises) {\n  return new Promise((resolve, reject) => {\n    for (const promise of promises) {\n      Promise.resolve(promise)\n        .then(resolve)\n        .catch(reject);\n    }\n  });\n}\n```\n\n\n\n\n\n### 数组去重\t\n\n```javascript\n// set\nArray.from(new Set(arr))\n// filter + index\narr.filter( (item ,index) =>{\n    return arr.indexOf(item) === index\n})\n// reduce\narr.reduce( (acc,cur) =>{\n    if (!acc.includes(cur)) {\n        acc.push(cur)\n    }\n    return acc\n},[] )\n```\n\n\n\n\n\n### 排序算法\n\n### 1. 冒泡排序（Bubble Sort）\n\n冒泡排序是一种简单的排序算法，通过重复地遍历列表，比较相邻元素并交换它们的位置，如果它们的顺序错误。这一过程会逐渐将最大或最小的元素“冒泡”到列表的一端。\n\n```javascript\nfunction bubbleSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        for (let j = 0; j < n - 1 - i; j++) {\n            if (arr[j] > arr[j + 1]) {\n                // 交换 arr[j] 和 arr[j + 1]\n                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            }\n        }\n    }\n    return arr;\n}\n\nconst arr = [64, 34, 25, 12, 22, 11, 90];\nconsole.log(bubbleSort(arr)); // 输出: [11, 12, 22, 25, 34, 64, 90]\n```\n\n### 2. 选择排序（Selection Sort）\n\n选择排序通过反复从未排序部分中选出最小（或最大）的元素，并将其放在已排序部分的末尾。它的主要特点是不断地选择最小元素，并将其移到已排序部分。\n\n```javascript\nfunction selectionSort(arr) {\n    let n = arr.length;\n    for (let i = 0; i < n - 1; i++) {\n        let minIndex = i;\n        for (let j = i + 1; j < n; j++) {\n            if (arr[j] < arr[minIndex]) {\n                minIndex = j;\n            }\n        }\n        // 交换 arr[i] 和 arr[minIndex]\n        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n    }\n    return arr;\n}\n\nconst arr = [64, 25, 12, 22, 11];\nconsole.log(selectionSort(arr)); // 输出: [11, 12, 22, 25, 64]\n```\n\n### 3. 插入排序（Insertion Sort）\n\n插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序）。\n\n#### 实现\n\n```javascript\nfunction insertionSort(arr) {\n    let n = arr.length;\n    for (let i = 1; i < n; i++) {\n        let key = arr[i];\n        let j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n    return arr;\n}\n\nconst arr = [12, 11, 13, 5, 6];\nconsole.log(insertionSort(arr)); // 输出: [5, 6, 11, 12, 13]\n```\n\n### 4. 快速排序（Quick Sort）\n\n快速排序是分治法的一种应用。它通过选择一个“基准”元素，将数组分成比基准小和比基准大的两部分，然后递归地排序这两部分。\n\n#### 实现\n\n```javascript\nfunction quickSort(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    let pivot = arr[Math.floor(arr.length / 2)];\n    let left = [];\n    let right = [];\n    for (let i = 0; i < arr.length; i++) {\n        if (i === Math.floor(arr.length / 2)) continue;\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return [...quickSort(left), pivot, ...quickSort(right)];\n}\n\nconst arr = [10, 7, 8, 9, 1, 5];\nconsole.log(quickSort(arr)); // 输出: [1, 5, 7, 8, 9, 10]\n```\n\n \n\n#### 总结\n\n这些基础的排序算法各有优缺点，适用于不同的场景：\n\n- **冒泡排序**、**选择排序** 和 **插入排序**：适合小规模数据集，简单易实现，但性能较差。\n- **快速排序** ：适合大规模数据集，具有较好的平均性能。\n\n\n\n\n\n### setTimeout 和 async/await的输出顺序\n\nPromises 和 `async/await` 放在微任务\t\tsetTimeout放在宏任务\n\n```js\nasync function asyncFunc() {\n  console.log('1'); //同步代码在执行栈\n  setTimeout(() => console.log('2'), 0); //宏\n  console.log('6');\n  await new Promise((resolve) => resolve('3')).then(console.log); // await回暂停并回到上文导致输出5 并执行完所有同步代码\n  console.log('4'); // \n  }\n\n  asyncFunc();\n  console.log('5');//同步代码在执行栈\n// 1 6 5 3 4 2\n\n// 但是普通promise是不会直接回到上文的 他会跳过当前command到后续的全局变量 然后跳出\nfunction asyncFunc() {\n    console.log('1'); //同步代码在执行栈\n    setTimeout(() => console.log('2'), 0); //宏\n    console.log('6');\n    new Promise((resolve) => resolve('3')).then(console.log); \n    new Promise( resolve => resolve('8'))\n        .then(num => num)\n        .then(num => console.log(num))\n    console.log('4'); // \n}\n\nasyncFunc();\nconsole.log('5');//同步代码在执行栈\n// 1 6 4 5 3 8 2 \n```\n\n**高难执行顺序** \n\n```javascript\nvar a;\nvar b = new Promise((resolve, reject) => {\n  console.log('promise1');\n  setTimeout(() => {\n    resolve()\n  }, 1000)\n}).then(() => {\n  console.log('promise2');\n}).then(() => {\n  console.log('promise3');\n}).then(() => {\n  console.log('promise4');\n})\na = new Promise(async (resolve) => {\n  console.log(a);\n  await b;\n  console.log('a');\n  console.log('after1');\n  await a;\n  resolve(true);\n  console.log('after2');\n});\nconsole.log('end');\n```\n\n\n\n### 输出顺序 闭包\n\n```\n1. 这段的输出结果是什么\n5个5 同时输出 因为var是在全局作用域 并且先执行同步代码 所以i的值先加到5再执行setTimeout\nfor (var i = 0; i < 5; i++) {\n    setTimeout(()=>{\n        console.log(i);\n    },1000)\n } \n\n2. 我想要0 1 2 3 4 把var改成let 这样是块级作用域\nfor (let i = 0; i < 5; i++) {\n    setTimeout(()=>{\n        console.log(i);\n    },1000)\n }  \n3. 我想要每一秒输出一个结果0 1 2 3 4, 改成1000*i 这样会记录每秒钟的i的值 比如i=1 1000*i = 1000 那么在1000时输出1\ni=2 1000 * 2 = 2000 那么在2000秒输出2\nfor (let i = 0; i < 5; i++) {\n    setTimeout(()=>{\n        console.log(i);\n    },1000 * i)\n } \n4.我不想用let 就是var 我怎么实现3的效果呢 闭包\nfor (var i = 0; i < 5; i++) {\n    (function(j){\n        setTimeout(()=>{\n            console.log(j);\n        },1000 * j)\n    })(i)\n}  \n\nfor (var i =0; i < 5; i++ ){\n    function logNum(j){\n    return function(){\n        console.log(j);\n    }\n}\n    setTimeout(logNum(i),1000*i)\n}\n```\n\n\n\nasync 和 defer\n\n `async` 脚本加载完成，会立即执行。此时，HTML 解析会暂时**中断**，直到脚本执行完毕后再继续。\n\n `defer` 脚本会等到 HTML **解析完毕**（DOM 完成构建）后再依次执行，保证脚本不会干扰 HTML 解析流程。\n\n\n\n## 性能优化总结\n\n1.压缩和优化JS、img、css资源\n\n2.异步加载js\n\n3.使用服务器缓存\n\n4.网络: CDN \n\n5.减小DOM复杂度\n\n\n\n# React\n\n#### React特性\n\n1. **组件化**\n2. **虚拟 DOM**：React 使用虚拟 DOM 来优化性能。虚拟 DOM 是 React 内部维护的一个轻量级副本，当状态或属性改变时，React 先更新虚拟 DOM，然后通过 Diff 算法比较新旧虚拟 DOM 的差异，只将真正有变化的部分同步到实际的 DOM 上。\n3. **单向数据流（Unidirectional Data Flow）**：React 采用单向数据流，父组件通过属性（props）将数据传递给子组件，而子组件不能直接修改父组件的数据。\n4. **JSX 语法**\n5. **声明式 UI**：React 通过声明式编程来构建用户界面。开发者只需声明界面应该如何渲染，React 会根据数据的变化自动更新界面，避免了手动 DOM 操作。\n6. **服务端渲染（SSR）**：React 支持服务端渲染，可以生成静态 HTML，减少首次加载时间，提升 SEO 效果。Next.js 是一个流行的基于 React 的框架，它提供了服务端渲染的解决方案。\n7. **Hooks**：Hooks 是 React 16.8 引入的一项特性，允许在函数组件中使用状态（`useState`）和其他 React 特性（比如 `useEffect`、`useContext`）。Hooks 大大简化了函数组件的使用，使得函数组件可以取代许多场景下的类组件。\n\n\n\n### React渲染阶段\n\nReact 的渲染流程可以分为两个主要阶段：**Render 阶段** 和 **Commit 阶段**。\n\nReact组件的更新过程\n\nrender 阶段\n\n        1. 调用组件的render方法 生成虚拟DOM树\n        2. reconciliation 协调 基于diff算法 比较新旧虚拟DOM树的不同 \n        3. 生成 Fiber 树\n\nCommit 阶段\n\n        1. 将Fiber树的变化 更新实际的DOM\n        2. 执行副作用 useEffect\n        3. 更新Ref\n\n### 1. 渲染流程概述\n\nReact 的渲染流程分为以下几个阶段：\n\n- **Render 阶段**：在此阶段，React 会计算和生成新的虚拟 DOM，找到与上次渲染的差异。\n- **Commit 阶段**：将计算出的差异应用到真实 DOM 中，完成界面的更新。\n\n在更详细的层面上，React 渲染过程包括以下步骤：\n\n1. **调度更新**：当状态或 props 发生变化时，React 会将更新放入调度队列，并通过调度器（scheduler）安排更新。\n2. **Render 阶段（Diff 阶段）**：React 在此阶段生成新的虚拟 DOM 树，并计算出哪些部分需要更新。这一过程是**可中断的**，React 可以根据需要暂停或重新开始，以确保高优先级任务（如用户交互）不会被阻塞。\n3. **Commit 阶段（DOM 更新阶段）**：React 将 Render 阶段生成的差异应用到真实 DOM 中，并触发生命周期钩子函数（如 `componentDidMount`、`componentDidUpdate` 等）。这一阶段是**不可中断的**，一旦开始就会完整地完成。\n\n### 2. Render 阶段（可中断）\n\nRender 阶段的主要目标是计算哪些部分的界面需要更新，并生成变更所需的虚拟 DOM 树。该阶段分为以下步骤：\n\n- **创建更新单元**：每次更新触发后，React 会根据组件树的结构生成一系列更新单元，称为 **Fiber 节点**。\n- **Fiber 树构建与 Diff**：React 将创建的 Fiber 树与上次渲染的 Fiber 树进行比较，通过 **Diff 算法**（虚拟 DOM diffing）确定哪些组件或 DOM 节点发生了变化。\n- **任务调度与优先级控制**：Render 阶段是**可中断的**，React 使用调度器（scheduler）在浏览器的空闲时间执行任务，确保高优先级任务（如用户输入）不会被阻塞。\n\nRender 阶段的产物是一个待提交的更新单元列表（包含需要更新的 DOM 节点和更新数据），供 Commit 阶段应用到真实 DOM 中。\n\n### 3. Commit 阶段（不可中断）\n\nCommit 阶段的目标是将 Render 阶段生成的更新实际应用到真实 DOM 中。此阶段的关键步骤如下：\n\n- **应用更新到 DOM**：React 根据 Render 阶段生成的更新单元，直接对 DOM 进行更新操作。\n- **触发生命周期钩子**：React 在 DOM 更新完成后触发生命周期钩子，包括 `componentDidMount`、`componentDidUpdate` 和 `useEffect` 的执行。\n- **更新真实 DOM 与界面同步**：此阶段会立即将变更应用到 DOM 中，因此用户可以看到界面的更新效果。\n\n由于 DOM 操作和生命周期钩子执行不可被中断，React 会确保在 Commit 阶段将所有变更完全应用，保证界面的状态一致性。\n\n### 4. 渲染流程图示\n\n整个流程可以用以下步骤来总结：\n\n1. **数据更新**：组件的状态或 props 发生改变，触发一次更新。\n2. **调度任务**：React 使用调度器管理更新的优先级，将更新推入调度队列。\n3. **Render 阶段**：\n   - 生成 Fiber 树，计算新的虚拟 DOM。\n   - 使用 Diff 算法与上次的虚拟 DOM 对比，确定变更。\n   - 中途可以被高优先级任务打断，分批执行。\n4. **Commit 阶段**：\n   - 将变更实际应用到真实 DOM。\n   - 触发生命周期钩子，使组件完成更新后的处理。\n   - 用户看到更新后的界面。\n\n### 5. React Fiber 对渲染流程的优化\n\nReact Fiber 是一种将渲染过程分成小块的架构，使渲染过程可以被打断并恢复，支持时间切片和任务调度，带来了以下优化：\n\n- **可中断的渲染**：Render 阶段可以暂停、恢复、终止，确保高优先级任务得到及时响应。\n- **任务优先级**：React Fiber 根据任务优先级来调度，提升用户体验。\n- **更细粒度的更新控制**：Render 阶段会分阶段渲染子树，提升性能，减少无意义的更新。\n\n\n\n\n\n\n\n#### Class Component 和 Function Component有什么区别\n\nReact 中的 Class Component 和 Function Component 是两种创建组件的方式，它们各有特点和使用场景。以下是它们的主要区别：\n\n### Class Component\n\n1. **定义方式**：\n   使用 ES6 类定义组件。\n\n   ```javascript\n   class MyComponent extends React.Component {\n       render() {\n           return <div>Hello, World!</div>;\n       }\n   }\n   ```\n\n2. **状态和生命周期**：\n   - 使用 `this.state` 管理状态。\n   - 使用生命周期方法（如 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 等）。\n\n   ```javascript\n   class MyComponent extends React.Component {\n       constructor(props) {\n           super(props);\n           this.state = { count: 0 };\n       }\n   \n       componentDidMount() {\n           // 在组件挂载后执行\n       }\n   \n       render() {\n           return <div>{this.state.count}</div>;\n       }\n   }\n   ```\n\n3. **使用场景**：\n   - 需要使用状态或生命周期方法时使用 Class Component。\n\n### Function Component\n\n1. **定义方式**：\n   使用函数定义组件。\n\n   ```javascript\n   function MyComponent() {\n       return <div>Hello, World!</div>;\n   }\n   ```\n\n2. **状态和生命周期（通过 Hooks）**：\n   - 使用 `useState` 管理状态。\n   - 使用 `useEffect` 处理副作用，相当于生命周期方法。\n\n   ```javascript\n   import React, { useState, useEffect } from 'react';\n   \n   function MyComponent() {\n       const [count, setCount] = useState(0);\n   \n       useEffect(() => {\n           // 在组件挂载和更新后执行\n       }, [count]); // 依赖项\n   \n       return <div>{count}</div>;\n   }\n   ```\n\n3. **使用场景**：\n   - 更简洁和易读，适合大多数情况。\n   - 没有this\n   - 使用 Hooks 提供的功能可以替代 Class Component 的状态和生命周期管理。\n\n\n\n\n\n\n\n### React 常见的hooks\n\n### 1. useState\n\n好处\n\n底层\n\n`useState` 是用于在函数组件中引入状态的 Hook。它返回一个状态变量和一个更新状态的函数。\n\n**示例代码：**\n\n```jsx\nimport React, { useState } from 'react';\n\nfunction Counter() {\n    const [count, setCount] = useState(0);\n\n    return (\n        <div>\n            <p>Count: {count}</p>\n            <button onClick={() => setCount(count + 1)}>Increment</button>\n        </div>\n    );\n}\n\nexport default Counter;\n```\n\n### 2. useEffect\n\n`useEffect` 是用于处理副作用的 Hook。它可以在组件渲染后执行某些操作，如数据获取、订阅或手动修改 DOM\n\n**示例代码：**\n\n```jsx\nimport React, { useEffect, useState } from 'react';\n\nfunction DataFetcher() {\n    const [data, setData] = useState(null);\n\n    useEffect(() => {\n        fetch('https://api.example.com/data')\n            .then(response => response.json())\n            .then(data => setData(data));\n    }, []); // 依赖数组为空，表示只在组件挂载和卸载时执行\n\n    return (\n        <div>\n            {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Loading...</p>}\n        </div>\n    );\n}\n\nexport default DataFetcher;\n```\n\n### 3. useContext\n\n`useContext` 是用于在函数组件中访问上下文的 Hook。\n\n父组件修改 子组件会重新渲染\n\n雅虎军规心能优化 3件套的\n\n**示例代码：**\n\n```jsx\nimport React, { useContext } from 'react';\n\nconst MyContext = React.createContext();\n\nfunction ChildComponent() {\n    const value = useContext(MyContext);\n\n    return <div>{value}</div>;\n}\n\nfunction ParentComponent() {\n    return (\n        <MyContext.Provider value=\"Hello, Context!\">\n            <ChildComponent />\n        </MyContext.Provider>\n    );\n}\n\nexport default ParentComponent;\n```\n\n### 4. useReducer\n\n`useReducer` 是用于替代 `useState` 处理复杂状态逻辑的 Hook。它适用于需要管理多个子值或复杂状态转变的情况。\n\n**示例代码：**\n\n```jsx\nimport React, { useReducer } from 'react';\n\nconst initialState = { count: 0 };\n\nfunction reducer(state, action) {\n    switch (action.type) {\n        case 'increment':\n            return { count: state.count + 1 };\n        case 'decrement':\n            return { count: state.count - 1 };\n        default:\n            throw new Error();\n    }\n}\n\nfunction Counter() {\n    const [state, dispatch] = useReducer(reducer, initialState);\n\n    return (\n        <div>\n            <p>Count: {state.count}</p>\n            <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>\n            <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>\n        </div>\n    );\n}\n\nexport default Counter;\n```\n\n### 5. useCallback\n\n`useCallback` 是用于返回一个记忆（缓存）的回调函数的 Hook，可以防止在每次渲染时重新创建回调函数，提高性能。\n\n**示例代码：**\n\n```jsx\nimport React, { useState, useCallback } from 'react';\n\nfunction ExpensiveCalculation({ calculate }) {\n    console.log('Calculating...');\n    return <div>Result: {calculate()}</div>;\n}\n\nfunction ParentComponent() {\n    const [count, setCount] = useState(0);\n\n    const calculate = useCallback(() => {\n        return count * 2;\n    }, [count]);\n\n    return (\n        <div>\n            <button onClick={() => setCount(count + 1)}>Increment</button>\n            <ExpensiveCalculation calculate={calculate} />\n        </div>\n    );\n}\n\nexport default ParentComponent;\n```\n\n### 6. useMemo\n\n`useMemo` 是用于返回一个记忆（缓存）的值的 Hook，可以防止在每次渲染时重新计算值，提高性能。\n\n**示例代码：**\n\n```jsx\nimport React, { useState, useMemo } from 'react';\n\nfunction ExpensiveCalculation({ count }) {\n    const result = useMemo(() => {\n        console.log('Calculating...');\n        return count * 2;\n    }, [count]);\n\n    return <div>Result: {result}</div>;\n}\n\nfunction ParentComponent() {\n    const [count, setCount] = useState(0);\n\n    return (\n        <div>\n            <button onClick={() => setCount(count + 1)}>Increment</button>\n            <ExpensiveCalculation count={count} />\n        </div>\n    );\n}\n\nexport default ParentComponent;\n```\n\n### 7. useRef\n\n`useRef` 是用于创建一个可以保存组件实例中变量的引用的 Hook。通常用于访问 DOM 元素或保存不触发重新渲染的变量。\n\n**示例代码：**\n\n```jsx\nimport React, { useRef } from 'react';\n\nfunction FocusInput() {\n    const inputRef = useRef(null);\n\n    const focusInput = () => {\n        inputRef.current.focus();\n    };\n\n    return (\n        <div>\n            <input ref={inputRef} type=\"text\" />\n            <button onClick={focusInput}>Focus Input</button>\n        </div>\n    );\n}\n\nexport default FocusInput;\n```\n\n### 8. useLayoutEffect\n\n`useLayoutEffect` 与 `useEffect` 类似，但它在所有 DOM 变更之后同步调用。适用于需要读取布局并同步重新渲染的情况。它会在浏览器绘制前运行。\n\n**示例代码：**\n\n```jsx\nimport React, { useLayoutEffect, useRef } from 'react';\n\nfunction LayoutEffectExample() {\n    const divRef = useRef(null);\n\n    useLayoutEffect(() => {\n        console.log(divRef.current.getBoundingClientRect());\n    }, []);\n\n    return <div ref={divRef}>Hello, useLayoutEffect!</div>;\n}\n\nexport default LayoutEffectExample;\n```\n\n\n\n### 为什么要出现react hooks\n\n很多情况下是来解决class component复杂的问题的 比如处理副作用 生命周期 state状态管理等等， 因为我确实不太懂class component具体怎么处理这些的， 所以就背下这些概念. \n\n\n\n### React 的组件之间的通信（props context 状态管理库redux ）\n\n### 1. 父子组件通信\n\n#### 通过 Props 传递数据\n\n父组件可以通过 props 向子组件传递数据和回调函数。子组件通过接收 props 来获取从父组件传递过来的数据。\n\n**示例代码：**\n\n```jsx\n// 父组件\nimport React from 'react';\nimport ChildComponent from './ChildComponent';\n\nfunction ParentComponent() {\n    const data = \"Hello from Parent\";\n\n    return (\n        <div>\n            <ChildComponent message={data} />\n        </div>\n    );\n}\n\nexport default ParentComponent;\n\n// 子组件\nimport React from 'react';\n\nfunction ChildComponent(props) {\n    return (\n        <div>\n            <p>{props.message}</p>\n        </div>\n    );\n}\n\nexport default ChildComponent;\n```\n\n### 2. 子父组件通信\n\n#### 通过回调函数传递数据\n\n子组件可以调用通过 props 传递的回调函数来向父组件发送数据。\n\n**示例代码：**\n\n```jsx\n// 父组件\nimport React, { useState } from 'react';\nimport ChildComponent from './ChildComponent';\n\nfunction ParentComponent() {\n    const [data, setData] = useState('');\n\n    const handleData = (childData) => {\n        setData(childData);\n    };\n\n    return (\n        <div>\n            <ChildComponent onData={handleData} />\n            <p>Data from child: {data}</p>\n        </div>\n    );\n}\n\nexport default ParentComponent;\n\n// 子组件\nimport React from 'react';\n\nfunction ChildComponent(props) {\n    const sendDataToParent = () => {\n        props.onData('Hello from Child');\n    };\n\n    return (\n        <div>\n            <button onClick={sendDataToParent}>Send Data to Parent</button>\n        </div>\n    );\n}\n\nexport default ChildComponent;\n```\n\n### 3. 兄弟组件通信\n\n#### 通过共同父组件传递数据\n\n兄弟组件可以通过共同的父组件来进行通信。父组件负责管理状态，并将状态通过 props 传递给兄弟组件。\n\n**示例代码：**\n\n```jsx\n// 父组件\nimport React, { useState } from 'react';\nimport SiblingOne from './SiblingOne';\nimport SiblingTwo from './SiblingTwo';\n\nfunction ParentComponent() {\n    const [data, setData] = useState('');\n\n    const handleData = (childData) => {\n        setData(childData);\n    };\n\n    return (\n        <div>\n            <SiblingOne onData={handleData} />\n            <SiblingTwo data={data} />\n        </div>\n    );\n}\n\nexport default ParentComponent;\n\n// 兄弟组件一\nimport React from 'react';\n\nfunction SiblingOne(props) {\n    const sendDataToParent = () => {\n        props.onData('Hello from SiblingOne');\n    };\n\n    return (\n        <div>\n            <button onClick={sendDataToParent}>Send Data to SiblingTwo</button>\n        </div>\n    );\n}\n\nexport default SiblingOne;\n\n// 兄弟组件二\nimport React from 'react';\n\nfunction SiblingTwo(props) {\n    return (\n        <div>\n            <p>Data from SiblingOne: {props.data}</p>\n        </div>\n    );\n}\n\nexport default SiblingTwo;\n```\n\n### 4. 使用 Context 进行跨层级通信\n\nReact Context 提供了一种不通过组件树逐层传递 props 就能在组件间共享值的方法。\n\n**示例代码：**\n\n```jsx\n// 创建 Context\nimport React, { createContext, useContext, useState } from 'react';\n\nconst MyContext = createContext();\n\n// 父组件\nfunction ParentComponent() {\n    const [data, setData] = useState('Hello from Context');\n\n    return (\n        <MyContext.Provider value={data}>\n            <ChildComponent />\n        </MyContext.Provider>\n    );\n}\n\nexport default ParentComponent;\n\n// 子组件\nfunction ChildComponent() {\n    const contextData = useContext(MyContext);\n\n    return (\n        <div>\n            <p>{contextData}</p>\n        </div>\n    );\n}\n```\n\n\n\n### 5.  Redux \n\n通过一个具体的业务场景来详细说明如何在 React 应用中使用 Redux来管理用户信息（如 `uID` 和 `name`）\n\n## 业务场景描述\n\n假设我们正在开发一个简单的用户管理系统，其中需要：\n\n1. **登录功能**：用户可以登录并查看他们的个人信息。\n2. **用户信息存储**：存储用户的 `uID` 和 `name`。\n3. **展示用户信息**：在应用的不同部分显示用户信息。\n\n为了实现这一功能，我们将使用 Redux 来集中管理应用的状态。\n\n## 步骤概述\n\n1. **设置 store.js**。\n2. **创建用户 Slice（使用 Redux Toolkit）**。\n3. **配置 Provider 以将 Store 提供给 React 应用**。\n4. **创建和连接 React 组件以访问和修改用户信息(useDispatch )**。\n\n### 1. 设置 Redux Store\n\nRedux Store 是 Redux 应用的核心，它保存着应用的所有状态。\n\n#### 创建 Store 文件\n\n在 `src` 目录下创建一个 `store.js` 文件：\n\n```javascript\n// src/store.js\nimport { configureStore } from '@reduxjs/toolkit';\nimport userReducer from './features/user/userSlice';\n\nconst store = configureStore({\n  reducer: {\n    user: userReducer,\n  },\n});\n\nexport default store;\n```\n\n**解释**：\n\n- `configureStore` 是 Redux Toolkit 提供的一个简化配置 Store 的方法，它自动设置好 Redux DevTools 和中间件。\n- `reducer` 字段接受一个对象，其中键是 state 的分片名称，值是相应的 reducer。这里我们创建了一个 `user` 的分片，由 `userReducer` 负责管理。\n\n### 2. 创建用户 Slice\n\n一个 slice 包含了 reducer 逻辑和相关的 actions。我们将创建一个用户 slice 来管理用户信息。\n\n#### 创建 User Slice 文件\n\n在 `src` 目录下创建一个 `features/user` 目录，并在其中创建 `userSlice.js` 文件：\n\n```javascript\n// src/features/user/userSlice.js\nimport { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n  uID: null,\n  name: '',\n};\n\nconst userSlice = createSlice({\n  name: 'user',\n  initialState,\n  reducers: {\n    setUser: (state, action) => {\n      state.uID = action.payload.uID;\n      state.name = action.payload.name;\n    },\n    clearUser: (state) => {\n      state.uID = null;\n      state.name = '';\n    },\n  },\n});\n// actions\nexport const { setUser, clearUser } = userSlice.actions;\n// 作为reducer\nexport default userSlice.reducer;\n```\n\n**解释**：\n\n- `createSlice` 允许我们定义 slice 的名称、初始状态以及 reducers。\n- `initialState` 定义了用户信息的初始状态，`uID` 和 `name` 初始为 `null` 和空字符串。\n- `reducers` 定义了可以修改 state 的方法，这里有两个：\n  - `setUser`：设置用户的 `uID` 和 `name`。\n  - `clearUser`：清除用户信息，将 `uID` 和 `name` 重置。\n- `userSlice.actions` 自动生成了对应的 action creators，我们将其导出以便在组件中使用。\n- `userSlice.reducer` 是生成的 reducer 函数，我们将在 Store 中使用它。\n\n### 3. 配置 Provider 以将 Store 提供给 React 应用\n\n要使 Redux Store 可用于整个 React 应用，需要使用 `Provider` 组件将 Store 提供给组件树。\n\n#### 修改 `index.js`\n\n```javascript\n// src/index.js\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport { Provider } from 'react-redux';\nimport store from './store';\nimport App from './App';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <Provider store={store}>\n    <App />\n  </Provider>\n);\n```\n\n**解释**：\n\n- `Provider` 组件来自 `react-redux`，用于将 Redux Store 提供给 React 组件树。\n- 将 `store` 作为 `Provider` 的 `store` 属性传递。\n\n### 4. 创建和连接 React 组件以访问和修改用户信息\n\n#### 4.1 创建 Login 组件\n\n```javascript\n// src/features/user/Login.js\nimport React, { useState } from 'react';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from './userSlice';\n\nconst Login = () => {\n  const dispatch = useDispatch(); //useDispatch\n  const [uID, setUID] = useState('');\n  const [name, setName] = useState('');\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (uID && name) {\n      dispatch(setUser({ uID, name })); //分发action\n      setUID('');\n      setName('');\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>用户 ID:</label>\n        <input\n          type=\"text\"\n          value={uID}\n          onChange={(e) => setUID(e.target.value)}\n          required\n        />\n      </div>\n      <div>\n        <label>姓名:</label>\n        <input\n          type=\"text\"\n          value={name}\n          onChange={(e) => setName(e.target.value)}\n          required\n        />\n      </div>\n      <button type=\"submit\">登录</button>\n    </form>\n  );\n};\n\nexport default Login;\n```\n\n**解释**：\n\n- 使用 `useState` 来管理表单输入的本地状态。\n- 使用 `useDispatch` 获取 `dispatch` 方法，以便分发 actions。\n- 在表单提交时，验证输入并使用 `dispatch(setUser({ uID, name }))` 将用户信息存储到 Redux Store 中。\n\n#### 4.2 创建 UserInfo 组件\n\n```javascript\n// src/features/user/UserInfo.js\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { clearUser } from './userSlice';\n\nconst UserInfo = () => {\n  const dispatch = useDispatch();\n  const user = useSelector((state) => state.user); //useSelector从Store 中获取user状态。\n\n  if (!user.uID) {\n    return <p>用户未登录</p>;\n  }\n\n  const handleLogout = () => {\n    dispatch(clearUser());\n  };\n\n  return (\n    <div>\n      <h2>用户信息</h2>\n      <p>用户 ID: {user.uID}</p>\n      <p>姓名: {user.name}</p>\n      <button onClick={handleLogout}>登出</button>\n    </div>\n  );\n};\n\nexport default UserInfo;\n```\n\n**解释**：\n\n- 使用 `useSelector` 从 Redux Store 中获取 `user` 状态。\n- 如果 `uID` 为空，显示“用户未登录”。\n- 如果用户已登录，显示用户信息，并提供登出按钮，通过 `dispatch(clearUser())` 清除用户信息。\n\n#### 5.3 修改 App 组件\n\n将 `Login` 和 `UserInfo` 组件集成到主应用中。\n\n```javascript\n// src/App.js\nimport React from 'react';\nimport Login from './features/user/Login';\nimport UserInfo from './features/user/UserInfo';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>用户管理系统</h1>\n      <Login />\n      <UserInfo />\n    </div>\n  );\n}\n\nexport default App;\n```\n\n\n\n### 5. 进一步优化和扩展\n\n以上是一个基础的 Redux 配置示例，用于存储和管理用户信息。根据实际需求，你可以进一步扩展，例如：\n\n- **异步操作**：使用 `createAsyncThunk` 处理异步请求，如从服务器获取用户信息。\n- **持久化 Store**：使用中间件如 `redux-persist` 将 Store 持久化到 `localStorage` 或 `sessionStorage`。\n- **更多的 Slice**：根据应用的复杂性，创建更多的 slice 来管理不同的状态。\n\n#### 5.1 添加异步操作示例\n\n假设我们需要从服务器获取用户信息，可以使用 `createAsyncThunk`。\n\n```javascript\n// src/features/user/userSlice.js\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit';\n\n// 异步获取用户信息的 thunk\nexport const fetchUser = createAsyncThunk('user/fetchUser', async (uID) => {\n  const response = await fetch(`/api/users/${uID}`);\n  if (!response.ok) {\n    throw new Error('网络响应错误');\n  }\n  const data = await response.json();\n  return data; // 假设返回的数据包含 { uID, name }\n});\n\nconst initialState = {\n  uID: null,\n  name: '',\n  status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'\n  error: null,\n};\n\nconst userSlice = createSlice({\n  name: 'user',\n  initialState,\n  reducers: {\n    setUser: (state, action) => {\n      state.uID = action.payload.uID;\n      state.name = action.payload.name;\n    },\n    clearUser: (state) => {\n      state.uID = null;\n      state.name = '';\n      state.status = 'idle';\n      state.error = null;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchUser.pending, (state) => {\n        state.status = 'loading';\n      })\n      .addCase(fetchUser.fulfilled, (state, action) => {\n        state.status = 'succeeded';\n        state.uID = action.payload.uID;\n        state.name = action.payload.name;\n      })\n      .addCase(fetchUser.rejected, (state, action) => {\n        state.status = 'failed';\n        state.error = action.error.message;\n      });\n  },\n});\n\nexport const { setUser, clearUser } = userSlice.actions;\n\nexport default userSlice.reducer;\n```\n\n**解释**：\n\n- `fetchUser` 是一个异步 thunk，用于从服务器获取用户信息。\n- 在 `extraReducers` 中处理 `fetchUser` 的不同状态（`pending`、`fulfilled`、`rejected`）。\n- 更新 `status` 和 `error` 以反映异步操作的状态。\n\n#### 8.2 在组件中使用异步操作\n\n```javascript\n// src/features/user/Login.js\nimport React, { useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport { fetchUser, setUser } from './userSlice';\n\nconst Login = () => {\n  const dispatch = useDispatch();\n  const [uID, setUID] = useState('');\n  const [name, setName] = useState('');\n  const userStatus = useSelector((state) => state.user.status);\n  const userError = useSelector((state) => state.user.error);\n\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (uID) {\n      dispatch(fetchUser(uID));\n    }\n  };\n\n  return (\n    <div>\n      <form onSubmit={handleSubmit}>\n        <div>\n          <label>用户 ID:</label>\n          <input\n            type=\"text\"\n            value={uID}\n            onChange={(e) => setUID(e.target.value)}\n            required\n          />\n        </div>\n        <button type=\"submit\">登录</button>\n      </form>\n      {userStatus === 'loading' && <p>正在登录...</p>}\n      {userStatus === 'failed' && <p>错误: {userError}</p>}\n    </div>\n  );\n};\n\nexport default Login;\n```\n\n**解释**：\n\n- 用户输入 `uID` 并提交后，触发 `fetchUser` 异步操作。\n- 根据 `user.status` 显示不同的状态信息。\n\n### 6. 总结\n\n通过以上步骤，我们完成了一个简单的 React 应用，使用 Redux 和 `react-redux` 来集中管理用户信息。以下是关键点总结：\n\n1. **Store 配置**：使用 Redux Toolkit 的 `configureStore` 简化了 Store 的配置。\n2. **Slice 创建**：使用 `createSlice` 定义了 state 和 reducer，自动生成了 action creators。\n3. **Provider 使用**：通过 `Provider` 组件将 Store 提供给 React 应用。\n4. **组件连接**：使用 `useSelector` 和 `useDispatch` 连接组件与 Redux Store，实现状态的读取和修改。\n5. **异步操作**：使用 `createAsyncThunk` 处理异步逻辑，如从服务器获取用户信息。\n\n   \n\n\n\n### React的Fiber\n\nFiber 是 React 的协调算法,使得 React 能够更好地管理复杂应用中的渲染性能问题\n\n在 之前的版本中，协调算法（reconciliation）是**同步**的，也就是说，一旦开始渲染一个组件树，React 会阻塞整个线程，直到渲染完成。如果组件树很大，或者渲染过程很复杂，可能会导致性能问题，尤其是在需要频繁更新 UI 的应用中，这可能会导致浏览器卡顿或掉帧。\n\nReact Fiber 解决了这一问题，通过将渲染工作**分割成多个小任务**，允许 React 在空闲时间段内完成这些任务，从而实现更平滑、更高效的用户界面更新。\n\n三个特点: \n\n1. **可中断渲染**：  \n传统的 React 是同步渲染的，一旦开始更新组件，直到整个更新结束才能响应其他任务。这可能会导致页面卡顿，尤其是遇到复杂更新时。React Fiber 改进了这一点，它将渲染任务分成多个小的工作单元，并且每完成一个小任务后，它会检查是否有更重要的任务需要处理。比如，用户的输入或者动画更新。如果有更高优先级的任务，Fiber 会暂时中断当前的渲染，优先处理那些任务，等到空闲时再继续未完成的渲染工作。这样，用户不会感到页面被卡住。\n2. **优先级调度**：  \nFiber 让 React 可以给不同的任务设定优先级。举个例子，像用户点击按钮、输入文本这些交互性操作，优先级会很高，因为用户需要及时的反馈。而其他一些数据更新、网络请求等操作优先级会低一些，可以稍后再处理。这种优先级调度机制确保了 React 先处理那些最重要的事情，让用户感觉应用更加灵活和快速。\n3. **阶段划分**：\n   Fiber 将渲染过程划分为两个阶段：\n   - **渲染阶段（render）**：这是任务的调度和协调阶段，在这一阶段，React 会构建更新的 UI 树。这一阶段是可以被打断的。\n   - **提交阶段 (commit)**：一旦渲染完成，React 会将更新提交到真实 DOM 上。这一阶段是同步的，不能被打断。\n\n\n\n\n\n\n\n\n\n\n\n## TS\n\n#### interface 和 type\n\n 都定义对象结构\n\n1. 都可以extends\n\n```typescript\ninterface Animal {\n  name: string;\n}\ninterface Dog extends Animal {\n  breed: string;\n}\ntype AnimalType = {\n  name: string;\n};\ntype DogType = AnimalType & {\n  breed: string;\n};\n```\n\n2.type 可以而 interface 不行\n\ntype 可以声明基本类型别名，联合类型，元组等类型\n\n```typescript\ntype Pet = Dog | Cat // 联合类型\ntype x = 'a' | 'b' | 'c' \n```\n\n3. interface 能够**声明合并**\n\n   ```\n   interface User {\n     name: string\n     age: number\n   }\n   \n   interface User {\n     sex: string\n   }\n   \n   /*\n   User 接口为 {\n     name: string\n     age: number\n     sex: string \n   }\n   */\n   ```\n\n   \n\n​\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 理论\n\n### 输入google.com 发生了什么\n\n1. www.google.com  通过dns 解析 转换成对应的IP地址\n\n 2. 建立TCP连接 该IP地址收到请求后 与 客户端发生三次握手进行连接(C => S SYN 包 S=>C SYN包 ACK包  C=>S ACK包 )\n 3. TCP连接建立后 客户端向服务端发起http请求(或者https) 和请求方式(get, post... 这里是get) \n  4. 服务端收到请求后返回 HTML、CSS、JavaScript 文件，以及其他资源（如图像、视频等）。\n  5. 客户端接受后浏览器进行渲染, HTML建立DOM树\n  6. 渲染完毕后 如果没有持续的通信请求 进行四次挥手关闭连接（C => S (FIN 包) S=>C(ACK 包 收到关闭请求) S=>C(FIN 包 表示数据已经发完) C=>S(ACK 收到关闭请求 并关闭连接)）\n\n**为什么需要3次不是两次** (C=>S SYN S=>C ACK)\n\n这样未经C端确认可能会导致过期的连接 在最后C端再向S端发送ACK可以保证现在的连接是有效的 确实需要连接\n\n\n\n### 简述TCP建立连接和断开连接\n\n### TCP 建立连接（三次握手）\n\nTCP建立连接的过程称为三次握手（Three-Way Handshake），步骤如下：\n\n1. **第一次握手（SYN）**：\n   - 客户端发送一个SYN（synchronize）标志位为1的TCP报文，指示要建立连接，并发送一个初始序列号（Sequence Number，简称SEQ），记作 `x`。\n   - 报文段格式：`SYN=x`\n\n2. **第二次握手（SYN-ACK）**：\n   - 服务器接收到SYN报文后，返回一个SYN-ACK报文。这个报文中包含服务器的初始序列号 `y`，并对客户端的序列号 `x` 进行确认（ACKnowledge），其确认号为 `x+1`。\n   - 报文段格式：`SYN=y, ACK=x+1`\n\n3. **第三次握手（ACK）**：\n   - 客户端接收到服务器的SYN-ACK报文后，再发送一个确认报文（ACK），确认号为 `y+1`，序列号为 `x+1`。此时，客户端和服务器都进入连接已建立（ESTABLISHED）状态。\n   - 报文段格式：`ACK=y+1`\n\n### TCP 断开连接（四次挥手）\n\nTCP断开连接的过程称为四次挥手（Four-Way Handshake），步骤如下：\n\n1. **第一次挥手（FIN）**：\n   - 客户端发送一个FIN（finish）标志位为1的TCP报文，指示要关闭连接，并发送一个序列号 `u`。\n   - 报文段格式：`FIN=u`\n\n2. **第二次挥手（ACK）**：\n   - 服务器接收到FIN报文后，发送一个确认报文（ACK），确认号为 `u+1`，表示已经接收到关闭连接的请求，但仍然可以继续发送未完成的数据。\n   - 报文段格式：`ACK=u+1`\n   - 此时，服务器进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。\n\n3. **第三次挥手（FIN）**：\n   - 服务器发送完所有数据后，发送一个FIN报文，指示可以关闭连接，并发送一个序列号 `v`。\n   - 报文段格式：`FIN=v`\n   - 此时，服务器进入LAST_ACK状态。\n\n4. **第四次挥手（ACK）**：\n   - 客户端接收到服务器的FIN报文后，发送一个确认报文（ACK），确认号为 `v+1`，表示已经接收到关闭连接的请求。\n   - 报文段格式：`ACK=v+1`\n   - 此时，客户端进入TIME_WAIT状态，等待一定时间（通常为2倍的MSL，Maximum Segment Lifetime）以确保服务器接收到确认报文后再进入CLOSED状态。\n   - 服务器在接收到确认报文后直接进入CLOSED状态。\n\n### 图示\n\n#### 三次握手\n\n```\nClient                  Server\n  |     SYN=x            |\n  |--------------------->|\n  |                      |\n  |     SYN=y, ACK=x+1   |\n  |<---------------------|\n  |                      |\n  |     ACK=y+1          |\n  |--------------------->|\n  |                      |\n```\n\n#### 四次挥手\n\n```\nClient                  Server\n  |     FIN=u            |\n  |--------------------->|\n  |                      |\n  |     ACK=u+1          |\n  |<---------------------|\n  |                      |\n  |     FIN=v            |\n  |<---------------------|\n  |                      |\n  |     ACK=v+1          |\n  |--------------------->|\n  |                      |\n```\n\n通过三次握手，客户端和服务器之间建立了可靠的连接。通过四次挥手，确保双方都能可靠地关闭连接并释放资源。这些机制是TCP协议提供可靠传输的重要保障。\n\n\n\n### 网络请求状态码\n\n### 1xx：信息性状态码\n- **100 Continue**：请求已接收，继续处理。\n- **101 Switching Protocols**：服务器正在切换协议。\n\n### 2xx：成功状态码\n- **200 OK**：请求成功，返回所请求的数据。\n- **201 Created**：成功请求并创建了新资源（如 POST 请求）。\n- **204 No Content**：请求成功，但没有返回内容。\n\n### 3xx：重定向状态码\n- **301 Moved Permanently**：请求的资源已永久移动到新 URL(用于永久性改变 URL，影响 **SEO** 和用户访问)\n- **302 Found**：请求的资源临时移动到其他 URL(原URL有效)\n- **304 Not Modified**：资源未修改，客户端可以使用缓存版本，减少不必要的网络请求,是一个缓存优化\n\n### 4xx：客户端错误状态码\n- **400 Bad Request**：请求无效，服务器无法理解。开发时**借口参数写错了**\n- **401 Unauthorized**：请求未授权，需进行身份验证。用户**没登录**\n- **403 Forbidden**：服务器拒绝请求，客户端无权访问。**权限**不足（普通用户/管理员） IP黑名单\n- **404 Not Found**：请求的资源未找到。\n\n### 5xx：服务器错误状态码\n- **500 Internal Server Error**：服务器发生意外错误。\n- **502 Bad Gateway**：作为网关或代理的服务器接收到无效响应。\n- **503 Service Unavailable**：服务器暂时无法处理请求（可能是维护中）\n\n\n\n\n\n### URL 查询字符串（Query String）\n\n#### 定义\n查询字符串用于在 URL 中传递额外的参数，格式为 `?key1=value1&key2=value2`。\n\n#### 组成\n- **`?`**：开始查询字符串\n- **`&`**：分隔多个参数\n- **`=`**：连接键和值\n\n#### 用途\n- **搜索**：`https://example.com/search?query=javascript`\n- **分页**：`https://example.com/articles?page=2&size=10`\n- **排序和过滤**：`https://example.com/products?sort=price&filter=available`\n- **追踪和分析**：`https://example.com/landing?utm_source=newsletter`\n\n#### 处理查询字符串\n**客户端**（JavaScript）：\n```javascript\nconst params = new URLSearchParams(window.location.search);\nconst query = params.get('query');\n```\n\n**服务器端**（Node.js）：\n```javascript\nconst querystring = require('querystring');\nconst params = querystring.parse(request.url.split('?')[1]);\n```\n\n#### URL 编码和解码\n```javascript\nconst encoded = encodeURIComponent('a value with spaces');\nconst decoded = decodeURIComponent(encoded);\n```\n\n### 示例\n```javascript\n// 示例 URL: https://example.com/search?query=javascript&page=2\nconst url = new URL('https://example.com/search?query=javascript&page=2');\nconst params = new URLSearchParams(url.search);\nconsole.log(params.get('query')); // 'javascript'\nconsole.log(params.get('page')); // '2'\n```\n\n\n\n## 前端安全\n\n#### XSS（跨站脚本攻击）\n\nInnerHTML或者Document.write会不编码 比如在一个input里输入一段脚本，他就会直接执行这个脚本了\n\n```html\n<script>alert('XSS Attack!');</script>\n```\n\n#### CSRF\n\n通过用户的身份在受信任网站上执行未授权的操作。\n\n#### CSRF 攻击的工作原理\n\n1. **用户在 A 网站上登录**：\n   \n   - 用户访问并登录到受信任的网站（A 网站），例如他们的银行或社交媒体账户。登录成功后，A 网站会在用户的浏览器中设置一个身份验证 Cookie，用于识别用户的登录状态。\n   \n2. **用户在浏览器中访问 B 网站**：\n   - 用户在登录 A 网站之后，继续浏览其他网页。此时，用户访问了一个由攻击者控制的恶意网站（B 网站）。用户在 A 网站的登录会话仍然有效，因为身份验证 Cookie 仍然存储在用户的浏览器中。\n\n3. **B 网站发起针对 A 网站的请求**：\n   - B 网站的页面包含一个表单或脚本，自动向 A 网站发送一个请求。这可能是通过自动提交表单、AJAX 请求或嵌入图像、脚本等方式发送的。\n   - 例如，B 网站的恶意页面可能包含如下代码，试图在用户不知情的情况下提交更改电子邮件地址的请求：\n\n     ```html\n     <form action=\"https://a-website.com/change-email\" method=\"POST\">\n         <input type=\"hidden\" name=\"email\" value=\"attacker@example.com\">\n         <input type=\"submit\" value=\"提交\">\n     </form>\n     ```\n\n     或者通过 JavaScript 自动提交该表单：\n\n     ```html\n     <img src=\"https://a-website.com/change-email?email=attacker@example.com\" style=\"display:none;\">\n     ```\n\n4. **浏览器携带 A 网站的 Cookie**：\n   - 当用户浏览 B 网站时，B 网站的脚本或表单会自动向 A 网站发送请求。由于浏览器会自动附带所有相关的 Cookie（包括 A 网站的身份验证 Cookie），A 网站会认为这个请求是合法用户发起的。\n\n5. **A 网站处理请求**：\n   - A 网站在收到请求时，由于 Cookie 的存在，会认为这是用户的合法请求，并按照请求执行操作，例如更改用户的电子邮件地址、执行资金转账等。\n\n### 关键点\n\n- **身份验证 Cookie**：这是 CSRF 攻击的核心。浏览器会自动附带与域名相关的 Cookie，而不会验证请求的来源。这使得在不同网站间发送请求时，即使是在恶意网站 B 上发起的请求，浏览器也会携带 A 网站的 Cookie。\n  \n- **用户不知情**：CSRF 攻击不依赖于用户的主动点击，只需要用户登录并拥有有效的会话。恶意代码可以在用户不知情的情况下发送请求。\n\n### 防止 CSRF 的措施\n\n1. **使用 CSRF 令牌**：\n   - 在每个表单请求中嵌入一个唯一的 CSRF 令牌，并在服务器端验证该令牌。攻击者无法从跨站请求中获取或伪造有效的 CSRF 令牌，这可以有效防止 CSRF 攻击。\n\n2. **SameSite Cookie 属性**：\n   - 设置 Cookie 的 `SameSite` 属性为 `Strict` 或 `Lax`，以限制 Cookie 只能在同源请求中发送。即使用户访问了恶意网站，恶意网站发起的跨站请求也不会包含用户的身份验证 Cookie。\n\n3. **验证 HTTP 请求头**：\n   - 检查 HTTP 请求的 `Origin` 和 `Referer` 头，确保请求来源是可信的。这种方法可以在某些情况下识别和阻止恶意请求。\n\n\n\n\n\n\n\n### 为什么要阻止跨域? 有具体例子嘛?\n\n跨域（CORS）是指浏览器从一个**源（域(`www.google.com`)、协议和端口）**请求资源时，资源位于另一个源。这种情况常常会遇到同源策略的限制。阻止跨域请求的主要目的是出于安全考虑，防止恶意网站从受信任的网站读取敏感信息。这种限制被称为同源策略（Same-Origin Policy）。\n\n### 为什么要阻止跨域请求？\n\n1. **保护用户数据**：防止恶意网站从另一个网站读取敏感数据（如用户的私人信息、浏览历史、会话数据等）。\n2. **防止 CSRF 攻击**：防止跨站请求伪造（Cross-Site Request Forgery, CSRF）攻击，恶意网站通过用户的身份在受信任网站上执行未授权的操作。\n3. **数据泄露**：防止数据泄露和未经授权的数据访问。\n\n### 具体例子\n\n#### 1. 保护用户数据\n\n假设用户登录到银行网站 `https://bank.example.com` 并在该网站上处理个人银行事务。如果不阻止跨域请求，恶意网站 `https://evil.example.com` 可以通过脚本发送请求到 `https://bank.example.com` 并获取用户的敏感数据。\n\n```html\n<!-- 恶意网站的页面 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Evil Site</title>\n    <script>\n        fetch('https://bank.example.com/account-details', {\n            credentials: 'include'\n        })\n        .then(response => response.json())\n        .then(data => {\n            console.log(data); // 读取用户的银行账户信息\n        });\n    </script>\n</head>\n<body>\n    <h1>Welcome to Evil Site</h1>\n</body>\n</html>\n```\n\n#### 2. 防止 CSRF 攻击\n\n假设用户已经登录到购物网站 `https://shop.example.com` 并且会话仍然有效。如果恶意网站 `https://evil.example.com` 发起一个请求，这个请求在用户的身份下运行，将会导致用户在不知情的情况下执行某些操作。\n\n```html\n<!-- 恶意网站的页面 -->\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Evil Site</title>\n</head>\n<body>\n    <h1>Welcome to Evil Site</h1>\n    <img src=\"https://shop.example.com/purchase?item=123&quantity=1\" style=\"display:none;\">\n    <!-- 上面的请求将在用户不知情的情况下购买商品 -->\n</body>\n</html>\n```\n\n### 如何解决跨域问题？\n\n虽然跨域请求被默认阻止，但有时需要跨域请求来访问不同域名下的资源。为了解决这个问题，CORS 规范提供了一种机制，允许服务器声明哪些源可以访问资源。\n\n#### 使用 CORS\n\n服务器可以在响应头中包含以下头信息来允许跨域请求：\n\n```http\nAccess-Control-Allow-Origin: https://example.com\n```\n\n#### 示例代码\n\n```javascript\n// Node.js 服务器端示例，使用 Express.js\nconst express = require('express');\nconst app = express();\n\napp.use((req, res, next) => {\n    res.header('Access-Control-Allow-Origin', 'https://example.com'); // 允许来自 https://example.com 的请求\n    res.header('Access-Control-Allow-Methods', 'GET, POST'); // 允许的 HTTP 方法\n    res.header('Access-Control-Allow-Headers', 'Content-Type'); // 允许的请求头\n    next();\n});\n\napp.get('/data', (req, res) => {\n    res.json({ message: 'This is CORS-enabled for example.com only!' });\n});\n\napp.listen(3000, () => {\n    console.log('CORS-enabled web server listening on port 3000');\n});\n```\n\n### 总结\n\n- **阻止跨域请求**：保护用户数据，防止 CSRF 攻击和数据泄露。\n- **CORS 机制**：允许服务器声明哪些源可以访问资源，以便在需要跨域请求时确保安全。\n\n通过理解和正确配置 CORS，可以在保护安全的同时，允许合法的跨域请求，从而实现更灵活的 Web 应用。\n\n\n\n\n\n### 浏览器是怎么进行渲染的\n\n1. **解析 HTML，构建 DOM 树**：\n   - 浏览器从上到下解析 HTML 文档，将各个 HTML 元素节点转化为 DOM（Document Object Model）树的节点。\n\n2. **解析 CSS，构建 CSSOM 树**：\n   - 解析 HTML 时，遇到 `<link>` 或 `<style>` 标签，浏览器会发起请求获取 CSS 文件或解析内联 CSS，构建 CSSOM（CSS Object Model）树。\n\n3. **处理 JavaScript**：\n   - 遇到 `<script>` 标签时，浏览器会下载并执行 JavaScript 脚本。\n   - 默认情况下，脚本执行会阻塞 HTML 解析。使用 `async` 属性，脚本会异步加载并执行，不阻塞解析。使用 `defer` 属性，脚本会在 HTML 解析完成后执行。\n\n4. **构建渲染树**：\n   - 浏览器将 DOM 树和 CSSOM 树合并，生成渲染树。渲染树包含每个可见元素的视觉样式信息。\n\n5. **布局（Layout）**：\n   - 浏览器根据渲染树进行布局计算（也称为“回流”或“重排”），确定每个元素的几何位置和尺寸。\n\n6. **绘制（Painting）**：\n   - 布局完成后，浏览器将渲染树中的元素绘制到屏幕上，显示最终的页面。\n\n\n\n### 堆空间和栈空间的区别\n\n### 1. 分配和管理方式\n\n- **栈空间**：\n  - 栈空间由编译器自动分配和释放，用于存储局部变量、函数参数和函数调用的返回地址。\n  - 栈的内存分配是连续的，内存释放是按照后进先出的顺序（LIFO）进行。\n  - 栈上的内存分配速度快，因为只需调整栈指针即可。\n\n- **堆空间**：\n  - 堆空间由程序员手动分配和释放，用于动态分配内存（如使用 `malloc`、`calloc`、`realloc` 在 C/C++ 中，或 `new` 在 C++ 中，`new` 在 JavaScript 中）。\n  - 堆的内存分配是非连续的，由操作系统或运行时库管理。\n  - 堆上的内存分配速度相对较慢，因为需要在自由存储区查找足够大的空闲块，并可能涉及到复杂的内存管理策略（如垃圾回收）。\n\n### 2. 存储内容\n\n- **栈空间**：\n  - 存储函数调用的上下文，包括局部变量、函数参数、返回地址等。\n  - 栈上的变量在函数调用结束时自动释放。\n\n- **堆空间**：\n  - 存储动态分配的内存块，如动态数组、链表、树等复杂数据结构。\n  - 堆上的内存需要程序员显式释放，否则会导致内存泄漏。\n\n### 3. 访问方式\n\n- **栈空间**：\n  - 变量通过栈帧偏移量直接访问，访问速度快。\n  - 栈上的内存生命周期受函数调用约束。\n\n- **堆空间**：\n  - 变量通过指针间接访问，访问速度相对较慢。\n  - 堆上的内存生命周期由程序员控制，可跨越函数调用。\n\n### 4. 内存限制\n\n- **栈空间**：\n  - 栈空间通常较小，受操作系统的限制。\n  - 过多的递归调用或分配过大的局部变量可能导致栈溢出（stack overflow）。\n\n- **堆空间**：\n  - 堆空间相对较大，但仍受系统可用内存的限制。\n  - 动态分配过多内存可能导致内存耗尽（out of memory）。\n\n### 总结\n\n- **栈空间**：用于存储局部变量和函数调用，分配和释放速度快，但内存容量较小，自动管理。\n- **堆空间**：用于动态内存分配，适合存储复杂数据结构，内存容量较大，但需要手动管理，分配和释放速度相对较慢。\n\n\n\n### HTTP 和 HTTPS 的区别\n\n**HTTP**：是一种不安全的协议，数据以明文形式传输 默认在80端口 更快 不需要SSL/TSL证书\n\n**HTTPS**： 加密  默认在443端口 需要SSL/TSL证书\n\n#### HTTP (HyperText Transfer Protocol)\n- **不安全**：HTTP 协议的数据在传输过程中是明文的，容易被窃听、篡改。\n- **端口**：默认使用端口 80。\n- **加密**：不使用加密机制。\n- **证书**：不需要证书。\n\n#### HTTPS (HyperText Transfer Protocol Secure)\n- **安全**：HTTPS 在 HTTP 的基础上增加了 SSL/TLS 协议，对数据进行加密，确保数据的机密性和完整性。\n- **端口**：默认使用端口 443。\n- **加密**：使用 SSL/TLS 协议进行加密。\n- **证书**：需要数字证书来验证服务器的身份。\n\n### 加密的工作原理\n\nHTTPS 使用 SSL/TLS 协议来加密数据。其工作原理可以概括为以下几个步骤：\n\n1. **客户端发送请求**：\n   - 客户端（如浏览器）请求 HTTPS 连接到服务器，并发送一个随机数（ClientHello），同时提供客户端支持的加密算法列表。\n\n2. **服务器响应**：\n   - 服务器发送服务器证书（包含公钥）和加密算法选择（ServerHello），并生成一个随机数。\n\n3. **客户端验证服务器证书**：\n   - 客户端验证服务器证书的有效性，如果证书可信，则继续。\n\n4. **生成会话密钥**：\n   - 客户端生成一个新的随机数，并使用服务器的公钥对该随机数进行加密，发送给服务器。服务器使用自己的私钥解密这个随机数。\n   - 现在客户端和服务器都拥有了三个随机数，双方使用这三个随机数生成会话密钥（对称加密密钥）。\n\n5. **数据加密传输**：\n   - 客户端和服务器使用生成的会话密钥对数据进行加密和解密。\n\n### 常用的加密算法\n\n#### 对称加密算法\n\n对称加密算法使用同一个密钥进行加密和解密，速度快，适用于大量数据加密。\n\n- **AES (Advanced Encryption Standard)**：一种广泛使用的对称加密算法，支持 128 位、192 位和 256 位密钥长度。\n- **DES (Data Encryption Standard)**：一种较旧的对称加密算法，安全性较低，已被 AES 替代。\n- **3DES (Triple DES)**：对 DES 的改进，使用三个不同的密钥进行三次加密，安全性较 DES 高，但速度较慢。\n\n#### 非对称加密算法\n\n非对称加密算法使用一对密钥（公钥和私钥）进行加密和解密，适用于密钥交换和数字签名。\n\n- **RSA (Rivest–Shamir–Adleman)**：一种广泛使用的非对称加密算法，适用于密钥交换和数字签名。\n- **ECC (Elliptic Curve Cryptography)**：一种基于椭圆曲线数学的非对称加密算法，提供更高的安全性和更小的密钥长度。\n\n#### 哈希算法\n\n哈希算法用于生成数据的唯一固定长度哈希值，常用于数据完整性校验和数字签名。\n\n- **SHA-256 (Secure Hash Algorithm 256-bit)**：SHA-2 家族的一种，生成 256 位的哈希值，广泛用于数据完整性校验和数字签名。\n- **MD5 (Message Digest Algorithm 5)**：一种较旧的哈希算法，生成 128 位的哈希值，已被认为不安全。\n\n### HTTPS 连接示例代码\n\n以下是使用 Node.js 实现一个简单的 HTTPS 服务器的示例代码：\n\n```javascript\nconst https = require('https');\nconst fs = require('fs');\n\n// 读取 SSL 证书\nconst options = {\n  key: fs.readFileSync('server.key'), // 私钥\n  cert: fs.readFileSync('server.crt') // 证书\n};\n\n// 创建 HTTPS 服务器\nhttps.createServer(options, (req, res) => {\n  res.writeHead(200);\n  res.end('Hello, HTTPS!\\n');\n}).listen(443);\n\nconsole.log('HTTPS server running on port 443');\n```\n\n### 结论\n\n- **HTTP**：不安全的明文传输协议，使用端口 80。\n- **HTTPS**：安全的加密传输协议，使用端口 443，需要 SSL/TLS 证书。\n- **常用加密算法**：包括对称加密（AES）、非对称加密（RSA、ECC）和哈希算法（SHA-256）。\n\n通过使用 HTTPS，可以确保客户端和服务器之间传输的数据的机密性、完整性和真实性。\n\n\n\nWebkit\n\n\n\n## HTTP 1.0 1.1 2.0 3.0\n\nHTTP协议是浏览器与服务器之间通信的协议\n\n**无状态**：HTTP是无状态协议，这意味着每次请求都是独立的，服务器不会自动记住之前请求的任何信息。为了维持状态（如用户登录），通常使用**Cookies**、**Sessions**或**Token**来存储用户信息。\n\n### HTTP 1.0\n\n**主要特点**：\n1. **无状态连接**：每个请求/响应对都是独立的，服务器不会保留前后请求的上下文。\n2. **每个请求一个连接**：客户端和服务器之间的每次请求和响应需要建立一个新的 TCP 连接。\n3. **基本功能**：提供基本的 GET、POST 和 HEAD 方法。\n\n**缺点**：\n- 连接开销大：每次请求都需要建立和关闭连接，效率低下。\n- 缺乏持久连接：无法在同一连接中发送多个请求，导致高延迟。\n\n### HTTP 1.1\n\n**主要改进**：\n1. **持久连接**：默认启用了持久连接（Connection: keep-alive），允许在一个 TCP 连接中发送多个请求和响应。\n2. **管道化**：允许在发送前一个响应之前发送多个请求，从而减少了等待时间。\n3. **额外的缓存控制**：引入了更多的缓存控制头，例如 ETag 和 If-Modified-Since。\n4. **带宽优化**：引入了分块传输编码（Chunked Transfer Encoding），允许服务器在不提前知道响应内容长度的情况下发送数据。\n5. **更多方法**：增加了 PUT、DELETE、OPTIONS 等方法。\n6. **虚拟主机支持**：通过 Host 头字段支持同一 IP 地址上的多个域名。\n\n**缺点**：\n- 虽然引入了持久连接和管道化，但由于队头阻塞(一个 TCP 连接只能处理一个请求)\n\n### HTTP 2.0\n\n**发布年份**：2015（RFC 7540）\n\n**主要改进**：\n1. **二进制协议**：将文本协议改为二进制协议，提高了解析效率和灵活性。\n2. **多路复用**：**一个 TCP 连接**同时**发送多个请求和响应**\n3. **头部压缩**：使用 HPACK 算法对头部进行压缩，减少了带宽消耗。\n4. **服务器推送**：服务器可以主动向客户端推送资源，减少延迟。\n5. **流优先级**：允许客户端指定流的优先级，以优化资源加载顺序。\n\n**缺点**：\n- 仍然依赖于单个 TCP 连接，存在潜在的队头阻塞问题，\n\n### HTTP 3.0\n\n**发布年份**：正在制定中（基于 QUIC，IETF 工作组正在进行标准化）\n\n**主要改进**：\n1. **基于 QUIC**：使用基于 UDP 的 QUIC 协议取代 TCP，提高连接建立速度和传输效率。\n2. **移除队头阻塞**：QUIC 协议内置多路复用和流控制，完全消除队头阻塞问题。\n3. **更快的连接建立**：使用 0-RTT 和 1-RTT 握手机制，显著减少连接建立时间。\n4. **内置加密**：所有 QUIC 连接默认都是加密的，增强了安全性。\n\n**优点**：\n- 在高延迟和高丢包率的网络环境下性能显著提升。\n- 更快的连接建立和数据传输。\n\n### 总结\n\n- **HTTP 1.0**：每个请求一个连接，无持久连接，效率低。\n- **HTTP 1.1**：引入持久连接和管道化，多请求一个连接，性能有所提升。\n- **HTTP 2.0**：二进制协议、多路复用、头部压缩和服务器推送，显著提升性能。\n- **HTTP 3.0**：基于 QUIC，移除队头阻塞，更快的连接建立和传输，增强的安全性。\n\n\n\n\n\n\n\n\n\n## CDN\n\n内容分发网络（Content Delivery Network，简称 CDN）是一种通过在全球范围内分布多个服务器节点，将内容缓存到离用户更近的服务器上，从而加速网站内容传输的技术。CDN 的主要目标是提高内容的访问速度、减少服务器负载和增强网站的可用性。\n\n### CDN 的工作原理\n\nCDN 的工作原理可以概括为以下几个步骤：\n\n1. **用户请求内容**：当用户访问某个网站时，浏览器会向网站服务器发送请求。\n2. **请求重定向**：CDN 根据用户的地理位置和当前的网络流量，将请求重定向到离用户最近的 CDN 节点。\n3. **内容缓存**：CDN 节点检查是否缓存了请求的内容。如果有缓存，直接将内容返回给用户；如果没有缓存，则向源服务器请求内容，并将其缓存以备将来使用。\n4. **内容传输**：CDN 节点将内容传输给用户，同时在缓存中保存副本，以便处理未来的请求。\n\n### CDN 的优点\n\n1. **加速内容传输**：通过将内容缓存到离用户更近的节点，可以显著减少延迟，加速内容的加载速度。\n2. **减轻服务器负载**：CDN 节点承担了大量的内容请求，减轻了源服务器的压力，从而提高了服务器的响应速度和稳定性。\n3. **提高可用性和可靠性**：CDN 节点分布在全球多个地方，即使某些节点出现故障，其他节点仍然可以继续提供服务，确保网站的高可用性。\n4. **增强安全性**：CDN 可以提供 DDoS 防护、Web 应用防火墙（WAF）等安全功能，保护网站免受恶意攻击。\n\n### CDN 的技术实现\n\nCDN 的技术实现通常包括以下几个关键组件：\n\n1. **缓存服务器**：分布在全球各地的服务器节点，用于缓存和提供内容。\n2. **负载均衡**：将用户请求分配到最合适的 CDN 节点，确保最佳性能和资源利用率。\n3. **内容缓存策略**：如 TTL（Time To Live）设置、缓存失效策略等，控制内容的缓存和更新。\n4. **网络监控和分析**：实时监控网络流量、性能和健康状态，确保 CDN 的高效运行。\n\n### 结论\n\nCDN 是一种重要的技术，通过在全球范围内分布多个服务器节点，将内容缓存到离用户更近的服务器上，从而加速网站内容传输、减轻服务器负载、提高网站的可用性和安全性。无论是静态资源还是动态内容，CDN 都能显著提升用户体验，是现代网站和应用程序优化的关键技术之一。\n\n\n\n### 游览器最大能保持多少个tcp连接\n\n6个 根据浏览器限制的\n\n\n\n\n\n##### 线程和进程\n\nProcess: 进程是操作系统分配资源的基本单位.\tOS支持同时运行多个进程，这就是多任务处理  开销较大\n\nThread:  线程是进程内的一个执行单元，是操作系统能够进行运算调度的最小单位。它被包含在进程中，是进程中实际运行工作的部分。\n\n1. **资源共享**：同一进程内的线程共享进程的资源（如内存空间）。这使得线程间的通信和数据共享更容易。\n2. **开销较小**：相比进程，线程的创建、销毁和切换的开销更小。\n3. **多线程**：一个进程可以有一个或多个线程。多线程可以实现在同一进程内的并行(parallel)操作。"
    },
    {
      "id": "git撤回操作指南",
      "metadata": {
        "permalink": "/en/blog/git撤回操作指南",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-07-18-git撤回操作指南.md",
        "source": "@site/blog/2024-07-18-git撤回操作指南.md",
        "title": "git撤回操作指南",
        "description": "warm-up",
        "date": "2024-07-18T00:00:00.000Z",
        "formattedDate": "July 18, 2024",
        "tags": [
          {
            "label": "git",
            "permalink": "/en/blog/tags/git"
          }
        ],
        "readingTime": 4.43,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "git撤回操作指南",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "git撤回操作指南",
          "title": "git撤回操作指南",
          "authors": {
            "name": "时雨",
            "title": "git撤回操作指南",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "git"
          ]
        },
        "prevItem": {
          "title": "面试笔记",
          "permalink": "/en/blog/面试笔记"
        },
        "nextItem": {
          "title": "周报2024-6-24",
          "permalink": "/en/blog/周报2024-6-24"
        }
      },
      "content": "#### warm-up\n\n​\t关于撤回你需要用到 `git reset`, 以下是参数解释:\n\n1. **`--soft`**：\n   - 保留变更在暂存区，这意味着你可以继续编辑这些文件或者直接重新提交\n   - 不带参数的`git reset --soft` 等同于`git reset --soft HEAD` (当前所在的提交,保留工作目录和暂存区的更改)\n   - `git reset --soft HEAD~1`：将当前分支的 HEAD 移动到上一个提交，但保留工作目录和暂存区的更改\n2. **`--mixed`**（默认选项）：\n   - 撤销提交并将变更保留在工作目录中，但移除暂存区的变更\n   - `git reset --mixed HEAD~1`：撤销上一次提交，并且取消对文件的暂存，但保留文件内容的更改\n3. **`--hard`**：\n   - 完全撤销提交，并删除工作目录中的所有更改\n   - 不带参数的`git reset --hard` 等同于`git reset --hard HEAD` (当前所在的提交,删除工作目录中的所有更改)\n   - `git reset --hard HEAD~1`：将 HEAD 移动到上一个提交，删除所有的暂存和工作目录中的更改\n4. **`HEAD`**：\n   - `HEAD` 指向当前的提交\n   - `HEAD~1` 指向当前提交的上一个提交\n   -  `HEAD~n` 指向更早的提交，其中 `n` 是需要回退的提交数\n\n比如这有一个文件`1.txt`和两段提交:\n\n![gitlog_spec](../static/Blog_img/img-git-withdrawal-operation/gitlog_spec.png)\n\n如果我们在`1.txt`里随便写上什么, 然后执行`git reset --hard`, git就把写的东西删除，恢复到当前HEAD也就是'first commit'的文件\n\n![gitresethardafterreset](../static/Blog_img/img-git-withdrawal-operation/gitresethardafterreset.png)\n\n**更直接的方式是reset到对应的版本号(git log中commit后黄色的哈希值)`git reset --soft <版本号>`**\n\n\n\n#### 1.本地撤回`git add` 和 `git commit`\n\n##### \t1.撤回`git add` \n\n​\t如果你已经使用 `git add .` 或 `git add <file>` 将文件添加到暂存区，但还没有提交，可以使用以下命令将文件从暂存区移除：\n\n​\t这一步只是将文件从暂存区移除, 会保留你对文件内容的更改\n\n```sh\ngit reset <file>\ngit reset // 撤回所有已添加的文件\n```\n\n##### \t2.撤回`git commit` \n\n​\t如果已经提交 `git commit -m \"some message\"` 但尚未push到远程仓库，可以使用以下命令撤回最后一次提交：\n\n`\t--soft` 选项会保留文件在暂存区中，这样你可以对其进行修改后再次提交。\n\n​\t这里需要`HEAD~1`的原因是HEAD已经变成commit后新的那一个了\n\n```sh\ngit reset --soft HEAD~1\n```\n\n\n\n#### 2.远程撤回`git push` \n\n##### 1.撤回最后一次提交\n\n假设我们错误推送了一次到远程仓库：\n\n![remotewrongpush](../static/Blog_img/img-git-withdrawal-operation/remotewrongpush.png)\n\n- 如果想撤回最后一次提交，并且确保其他人还没有从远程仓库拉取这次提交，可以使用：\n\n  ```bash\n  git reset --hard HEAD~1 // 或者直接reset到你想要的commit的版本号\n  git push origin <branch> --force\n  ```\n\n可以看到这条记录已经被删除了\n\n![remoteAfterReset](../static/Blog_img/img-git-withdrawal-operation/remoteAfterReset.png)\n\n注意：`--force` 选项会覆盖远程仓库的历史记录，如果其他人已经从远程仓库拉取了这次提交，可能会导致问题(分支不一致, 丢失提交)\n\n\n\n##### 2.使用 `git revert`:\n\n​\t如果你不想强制覆盖远程仓库的历史，可以使用 `git revert` 创建一个新的提交，撤销之前的更改：\n\n```\ngit log //获取需要revert的hash值 \ngit revert <commit> //commit就是log中获取的hash值\ngit push origin <branch>\n```\n\n这将生成一个新的提交，revert指定提交的更改，从而保持提交历史的完整性。\n\n![revert](../static/Blog_img/img-git-withdrawal-operation/revert.png)"
    },
    {
      "id": "周报2024-6-24",
      "metadata": {
        "permalink": "/en/blog/周报2024-6-24",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2024-06-24.md",
        "source": "@site/blog/2024-06-24.md",
        "title": "周报2024-6-24",
        "description": "六月的最后一周,也是博客复活的一周.不知道想写啥,随便弄点",
        "date": "2024-06-24T00:00:00.000Z",
        "formattedDate": "June 24, 2024",
        "tags": [
          {
            "label": "weekly",
            "permalink": "/en/blog/tags/weekly"
          }
        ],
        "readingTime": 0.25,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "面试代码",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "周报2024-6-24",
          "title": "周报2024-6-24",
          "authors": {
            "name": "时雨",
            "title": "面试代码",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "weekly"
          ]
        },
        "prevItem": {
          "title": "git撤回操作指南",
          "permalink": "/en/blog/git撤回操作指南"
        },
        "nextItem": {
          "title": "面试题代码",
          "permalink": "/en/blog/面试题代码"
        }
      },
      "content": "六月的最后一周,也是博客复活的一周.不知道想写啥,随便弄点\n\n#### 学习计划\n​\t\tReact文档\n​\t\tjs红宝书\n​\t\t项目\n       重构下博客的UI\n\n​"
    },
    {
      "id": "面试题代码",
      "metadata": {
        "permalink": "/en/blog/面试题代码",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-09-28-面试代码.md",
        "source": "@site/blog/2023-09-28-面试代码.md",
        "title": "面试题代码",
        "description": "防抖用于确保在一系列事件结束后执行函数，而节流用于限制函数的执行频率，以控制事件触发频率",
        "date": "2023-09-28T00:00:00.000Z",
        "formattedDate": "September 28, 2023",
        "tags": [
          {
            "label": "JS",
            "permalink": "/en/blog/tags/js"
          }
        ],
        "readingTime": 4.445,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "面试代码",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "面试题代码",
          "title": "面试题代码",
          "authors": {
            "name": "时雨",
            "title": "面试代码",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "JS"
          ]
        },
        "prevItem": {
          "title": "周报2024-6-24",
          "permalink": "/en/blog/周报2024-6-24"
        },
        "nextItem": {
          "title": "Promise",
          "permalink": "/en/blog/Promise"
        }
      },
      "content": "防抖用于确保在一系列事件结束后执行函数，而节流用于限制函数的执行频率，以控制事件触发频率\n\n### 防抖\n\n- 防抖的主要思想是在一系列连续的事件触发后，只执行一次函数。\n- 当事件触发后，定时器会设置一个延迟（例如，300毫秒），如果在延迟内没有再次触发事件，那么函数会执行一次。\n- 如果在延迟期间又触发了相同的事件，定时器会被重新设置，延迟重新计时。\n- 防抖适用于例如输入框输入事件，滚动事件等可能高频触发的情况，以减少不必要的函数执行，避免过多的计算或请求。\n\n```js\nvar debounce = function(fn, t) {\n    let timer = null\n    return function(...args) {\n        if(timer){\n            clearTimeout(timer)\n            timer = null\n        }\n        timer = setTimeout(()=>{\n            // fn(...args);\n            fn.apply(this,args)\n        },t)\n    }\n};\n```\n\n### 节流\n\n- 节流的主要思想是在一系列连续的事件触发中，控制函数的执行频率，例如每隔一段时间执行一次。\n- 定时器会设置一个间隔（例如，300毫秒），如果在间隔内触发多次事件，只有第一次触发会执行函数，其他触发会被忽略。\n- 在间隔结束后，才能再次触发函数执行。\n- 节流适用于例如滚动事件、鼠标移动事件等需要限制执行频率的情况，以避免过多的函数执行。\n\n```js\nvar throttle = function(fn, t) {\n    let timer = null\n    return function(...args) {\n        if (timer === null) {\n            timer = setTimeout(()=>{\n                fn(...args)\n                timer = null\n            },t)\n        }\n    }\n};\n```\n\n### 浅拷贝\n\n如果是数组，我们可以利用数组的一些方法比如：slice、concat 返回一个新数组的特性来实现浅拷贝\n\n```js\nconst arr = ['old', 1, true, null, undefined];\n\nconst new_arr = arr.concat();\nconst new_arr_slice = arr.slice();\nnew_arr[0] = 'new';\n\nconsole.log(arr) // [\"old\", 1, true, null, undefined]\nconsole.log(new_arr) // [\"new\", 1, true, null, undefined]\nconsole.log(new_arr_slice) // [\"old\", 1, true, null, undefined]\n```\n\n但是如果数组嵌套了对象或者数组的话，比如：\n\n```js\nconst arr = [{old: 'old'}, ['old']];\nconst new_arr = arr.slice();\n\narr[0].old = 'new';\narr[1][0] = 'new';\n\nconsole.log(arr) // [{old: 'new'}, ['new']]\nconsole.log(new_arr) // [{old: 'new'}, ['new']]\n```\n\n如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。\n\n这种复制引用的拷贝方法称之为浅拷贝，对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。\n\n### 深拷贝\n\n深拷贝数组\n\nstringify 对象或值转换为 JSON 字符串\n\n```js\nconst arr = ['old', 1, true, ['old1', 'old2'], {old: 1}]\nconst new_arr = JSON.parse(JSON.stringify(arr))\narr[0] = 'new';\narr[4][1] = 'new11';\nconsole.log(arr);   //['new',...]\nconsole.log(new_arr); //['old',...]\n```\n\n### 浅拷贝的实现\n\n```js\nconst shallowCopy = function(obj) {\n    // 只拷贝对象\n    if (typeof obj !== 'object') return;\n    // 根据obj的类型判断是新建一个数组还是对象\n    let newObj = obj instanceof Array ? [] : {};\n    // 遍历obj，并且判断是obj的属性才拷贝\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = obj[key];\n        }\n    }\n    return newObj;\n}\n```\n\n### 深拷贝的实现\n\n拷贝的时候判断一下属性值的类型，如果是对象，递归调用深拷贝函数\n\n```js\nconst deepCopy = function(obj) {\n    if (typeof obj !== 'object') return;\n    let newObj = obj instanceof Array ? [] : {};\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key];\n        }\n    }\n    return newObj;\n}\n```"
    },
    {
      "id": "Promise",
      "metadata": {
        "permalink": "/en/blog/Promise",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-07-14-Promise笔记.md",
        "source": "@site/blog/2023-07-14-Promise笔记.md",
        "title": "Promise",
        "description": "1.回调地狱",
        "date": "2023-07-14T00:00:00.000Z",
        "formattedDate": "July 14, 2023",
        "tags": [
          {
            "label": "JS",
            "permalink": "/en/blog/tags/js"
          }
        ],
        "readingTime": 4.69,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "Promise笔记",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "Promise",
          "title": "Promise",
          "authors": {
            "name": "时雨",
            "title": "Promise笔记",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "JS"
          ]
        },
        "prevItem": {
          "title": "面试题代码",
          "permalink": "/en/blog/面试题代码"
        },
        "nextItem": {
          "title": "二叉树 递归",
          "permalink": "/en/blog/二叉树 递归"
        }
      },
      "content": "### 1.回调地狱\n\n​\t\t回调函数中嵌套回调\n\n```js\nfunction fn1(n){\n  \tn = n + 1\n    fn2(n)\n    function fn2(n){\n        n = n + 2\n        fn3(n)\n        console.log('2:',n);\n        function fn3(n){\n            n = n + 3\n            fn4(n)\n            console.log('3:',n);\n            function fn4(n){\n                n = n + 4\n                console.log('4:',n);\n            }\n        }\n    }\n    console.log('1:',n);\n}\n        \n    fn1(10) // 20 16 13 11\n```\n\n\n\n##### \t**为什么需要Promise**\n\n​\t\tPromise解决了回调地狱\n\n\n\n### 2.Promise 的基本使用\n\n##### 参数\n\nPromise 作为一个构造函数, 接受一个函数作为参数\n\n- 在参数函数中有两个参数\n\n- - resolve: 成功函数\n  - reject: 失败函数\n\n```js\n const p = new Promise((resolve,reject)=>{})\n console.dir(p);\n\n//[[Prototype]]: Promise \n//[[PromiseState]]: \"pending\"\n//[[PromiseResult]]: undefined\n```\n\n##### 属性\n\npromise实例有两个属性\n\n- state: 状态\n- result: 结果\n\n\n\n#### 1) Promise的状态（state）\n\n第一种状态: pending (准备)\n\n第二种状态: fulfilled (已完成)\n\n第三种状态: rejected (拒绝)\n\n\n\n#### 2) Promise状态的改变\n\n通过调用resolve() reject() 改变Promise的状态\n\n##### resolve() \n\n使当前Promise状态改成fulfilled\n\n```js\nconst p = new Promise((resolve,reject)=>{\n        resolve()\n })\nconsole.dir(p);\n//[[PromiseState]]: \"fulfilled\"\n```\n\n\n\n##### reject()\t\n\n使当前Promise状态改成 rejected\n\n```js\nconst p = new Promise((resolve,reject)=>{\n        reject()\n })\nconsole.dir(p);\n//[[PromiseState]]: \"rejected\"\n```\n\n\n\nPromise状态只能改变一次\n\n```js\nconst p = new Promise((resolve,reject)=>{\n\t\t\t\tresolve()\n        reject()\n })\nconsole.dir(p);\n//[[PromiseState]]: \"fulfilled\n```\n\n\n\n#### 3) Promise 的结果(result)\n\n##### resolve()\n\n 通过调用 resolve() 传递参数,改变 当前Promise对象的结果\n\n```js\nconst p = new Promise((resolve,reject)=>{\n      resolve('成功的结果')\n})\nconsole.dir(p);\n//[[PromiseState]]: \"fulfilled\n//[[PromiseResult]]: \"成功的结果\"\n```\n\n##### reject()\n\n```js\nconst p = new Promise((resolve,reject)=>{\n      resolve('失败的结果')\n})\nconsole.dir(p);\n//[[PromiseState]]: \"rejected\"\n//[[PromiseResult]]: \"失败的结果\"\n```\n\n\n\n### 3. Promise的方法\n\n实例使用原型的方法\n\n#### 1) then方法\n\n##### 参数 (两个)\n\n​\t1：函数 (执行成功(fulfilled)的语句)\n\n​\t2:   也是函数(执行失败(rejected)的语句)\n\n##### 返回值 \n\n​\t是一个Promise对象\n\n```js\n// p.then(()=>{ }, ()=>{ })\nconst p = new Promise((resolve,reject)=>{\n    resolve('成功的结果')\n    //reject('失败的结果')\n})\np.then(()=>{\n    console.log('成功时调用');\n},()=>{\n    console.log('失败时调用');\n})\nconsole.dir(p);\n//\"成功时调用\"\n```\n\n##### then方法的形参\n\n可以看到then方法里的形参返回的是resolve里的参数\n\n```js\nconst p = new Promise((resolve,reject)=>{\n    // resolve('成功的结果')\n    reject('失败的结果')\n})\np.then((value)=>{\n    console.log('成功时调用',value);\n},(error)=>{\n    console.log('失败时调用',error);\n})\nconsole.dir(p);\n//成功时调用 成功的结果\n//失败时调用 失败的结果\n```\n\n返回值 是一个Promise对象\n\n 设一个t接住 p.then(),可以发现t还是一个promise对象\n\n```js\nconst t = p.then((value)=>{\n    console.log('成功时调用',value);\n},(error)=>{\n    console.log('失败时调用',error);\n})\n\nconsole.dir(t);\n\n// 这里t的状态是pending\n```\n\n##### 链式操作\n\n由于then()方法依旧返回Promise实例 所以可以多用几个then接住\n\n```\nnew Promise((resolve,reject)=>{}).then().then()\n```\n\n\n\nPromise的状态不改变,不执行then()方法\n\n```js\n// 这里的then不执行\nnew Promise((resolve,reject)=>{\n  resolve('成功')\n  // reject('失败')\n}).then(()=>{\n    console.log('成功时调用');\n  \t\treturn '第一个then成功了'\n},()=>{\n    console.log('失败时调用');\n}).then(()=>{\n    console.log('成功时调用');\n},()=>{\n    console.log('失败时调用');\n})\nconsole.dir(p);\n```\n\n第一个 then结束后 状态是pending. 此时不能直接调用第二个then()方法执行, \n\n在then()方法中  `return ` 可以将实例的状态改成fulfilled\n\n\n\n####  2)catch方法\n\n catch中的参数函数在什么时候被执行：\n\n​\t\t当Promise的状态改为rejcted.被执行\n​\t\t当Promise执行体中出现代码错误时,被执行\n\n```js\np.catch(()=>{})\n```\n\n```js\n const p = new Promise((resolve,reject)=>{\n    // resolve(' promise成功')\n    reject('promise失败')\n})\np.catch(()=>{\n  \tconsole.log('失败');\n})\nconsole.dir(p);\n// 失败\n```\n\n\n\n\n\n### 4.用Promise修改回调地狱\n\n原代码\n\n```js\nfunction fn1(n){\n  \tn = n + 1\n    fn2(n)\n    function fn2(n){\n        n = n + 2\n        fn3(n)\n        console.log('2:',n);\n        function fn3(n){\n            n = n + 3\n            fn4(n)\n            console.log('3:',n);\n            function fn4(n){\n                n = n + 4\n                console.log('4:',n);\n            }\n        }\n    }\n    console.log('1:',n);\n}\n        \n    fn1(10) // 20 16 13 11\n```\n\n\n\nPromise:\n\n```js\nconst p = new Promise((resolve, reject) => {\n    resolve(10);\n}).then((value) => {\n    value = value + 1;\n    return value;\n}).then((value) => {\n    value = value + 2;\n    return value;\n}).then((value) => {\n    value = value + 3;\n    return value;\n}).then((value) => {\n    value = value + 4;\n    return value;\n})\n  .catch((error) => {\n    console.log('计算失败');\n});\n\np.then((final) => {\n    console.log(final);\n});\n```"
    },
    {
      "id": "二叉树 递归",
      "metadata": {
        "permalink": "/en/blog/二叉树 递归",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-07-14-二叉树递归.md",
        "source": "@site/blog/2023-07-14-二叉树递归.md",
        "title": "二叉树 递归",
        "description": "104.二叉树的最大深度",
        "date": "2023-07-14T00:00:00.000Z",
        "formattedDate": "July 14, 2023",
        "tags": [
          {
            "label": "算法",
            "permalink": "/en/blog/tags/算法"
          }
        ],
        "readingTime": 0.285,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "二叉树 递归",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "二叉树 递归",
          "title": "二叉树 递归",
          "authors": {
            "name": "时雨",
            "title": "二叉树 递归",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "算法"
          ]
        },
        "prevItem": {
          "title": "Promise",
          "permalink": "/en/blog/Promise"
        },
        "nextItem": {
          "title": "链表题汇总",
          "permalink": "/en/blog/链表题汇总"
        }
      },
      "content": "104.[二叉树的最大深度 ](https://leetcode.cn/problems/maximum-depth-of-binary-tree)\n\n111.[二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/ )\n\n112.[路径总和](https://leetcode.cn/problems/path-sum/)\n\n113.[路径总和 II](https://leetcode.cn/problems/path-sum-ii/)\n\n129.[求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\n\n257.[二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)"
    },
    {
      "id": "链表题汇总",
      "metadata": {
        "permalink": "/en/blog/链表题汇总",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-07-14-链表题汇总.md",
        "source": "@site/blog/2023-07-14-链表题汇总.md",
        "title": "链表题汇总",
        "description": "1.反转链表",
        "date": "2023-07-14T00:00:00.000Z",
        "formattedDate": "July 14, 2023",
        "tags": [
          {
            "label": "算法",
            "permalink": "/en/blog/tags/算法"
          }
        ],
        "readingTime": 0.77,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "链表题汇总",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "链表题汇总",
          "title": "链表题汇总",
          "authors": {
            "name": "时雨",
            "title": "链表题汇总",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "算法"
          ]
        },
        "prevItem": {
          "title": "二叉树 递归",
          "permalink": "/en/blog/二叉树 递归"
        },
        "nextItem": {
          "title": "First Blog Post",
          "permalink": "/en/blog/first-blog-post"
        }
      },
      "content": "### 1.反转链表\n\n206.[反转链表](https://leetcode-cn.com/problems/reverse-linked-list)\n\n92.[反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii)\n\n25.[K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group)\n\n24.[两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs)\n\n445.[两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii)\n\n\n\n### 2.快慢指针 环形链表\n\n876.[链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list)\n\n141.[环形链表](https://leetcode.cn/problems/linked-list-cycle)\n\n142.[环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii)\n\n143.[重排链表](https://leetcode.cn/problems/reorder-list)\n\n234.[回文链表](https://leetcode.cn/problems/palindrome-linked-list)\n\n### 3.链表删除\n237.[删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)\n\n19.[删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list)\n\n83.[删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list)\n\n82.[删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii)\n\n203.[移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements)"
    },
    {
      "id": "first-blog-post",
      "metadata": {
        "permalink": "/en/blog/first-blog-post",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-07-07-first-blog-post.md",
        "source": "@site/blog/2023-07-07-first-blog-post.md",
        "title": "First Blog Post",
        "description": "第一篇博客",
        "date": "2023-07-07T00:00:00.000Z",
        "formattedDate": "July 7, 2023",
        "tags": [
          {
            "label": "随笔",
            "permalink": "/en/blog/tags/随笔"
          }
        ],
        "readingTime": 0.065,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "First Post",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          }
        ],
        "frontMatter": {
          "slug": "first-blog-post",
          "title": "First Blog Post",
          "authors": {
            "name": "时雨",
            "title": "First Post",
            "url": "https://github.com/KAGA11",
            "image_url": "https://github.com/KAGA11.png",
            "imageURL": "https://github.com/KAGA11.png"
          },
          "tags": [
            "随笔"
          ]
        },
        "prevItem": {
          "title": "链表题汇总",
          "permalink": "/en/blog/链表题汇总"
        },
        "nextItem": {
          "title": "代码块写法",
          "permalink": "/en/blog/代码块写法"
        }
      },
      "content": "第一篇博客\n写于2023年7月7日"
    },
    {
      "id": "代码块写法",
      "metadata": {
        "permalink": "/en/blog/代码块写法",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2023-07-07-代码块写法.mdx",
        "source": "@site/blog/2023-07-07-代码块写法.mdx",
        "title": "代码块写法",
        "description": "Blog posts support Docusaurus Markdown features, such as MDX.",
        "date": "2023-07-07T00:00:00.000Z",
        "formattedDate": "July 7, 2023",
        "tags": [
          {
            "label": "博客格式",
            "permalink": "/en/blog/tags/博客格式"
          }
        ],
        "readingTime": 0.175,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "First Post",
            "url": "https://github.com/KAGA11",
            "imageURL": "https://github.com/KAGA11.png",
            "key": "shigure"
          }
        ],
        "frontMatter": {
          "slug": "代码块写法",
          "title": "代码块写法",
          "authors": [
            "shigure"
          ],
          "tags": [
            "博客格式"
          ]
        },
        "prevItem": {
          "title": "First Blog Post",
          "permalink": "/en/blog/first-blog-post"
        },
        "nextItem": {
          "title": "Welcome",
          "permalink": "/en/blog/welcome"
        }
      },
      "content": "Blog posts support [Docusaurus Markdown features](https://docusaurus.io/docs/markdown-features), such as [MDX](https://mdxjs.com/).\n\n:::tip\n\nUse the power of React to create interactive blog posts.\n\n```js\n<button onClick={() => alert('button clicked!')}>Click me!</button>\n```\n\n<button onClick={() => alert('button clicked!')}>Click me!</button>\n\n:::"
    },
    {
      "id": "welcome",
      "metadata": {
        "permalink": "/en/blog/welcome",
        "editUrl": "https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2021-08-26-welcome/index.md",
        "source": "@site/blog/2021-08-26-welcome/index.md",
        "title": "Welcome",
        "description": "Docusaurus blogging features are powered by the blog plugin.",
        "date": "2021-08-26T00:00:00.000Z",
        "formattedDate": "August 26, 2021",
        "tags": [
          {
            "label": "博客格式",
            "permalink": "/en/blog/tags/博客格式"
          }
        ],
        "readingTime": 0.405,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "时雨",
            "title": "First Post",
            "url": "https://github.com/KAGA11",
            "imageURL": "https://github.com/KAGA11.png",
            "key": "shigure"
          }
        ],
        "frontMatter": {
          "slug": "welcome",
          "title": "Welcome",
          "authors": [
            "shigure"
          ],
          "tags": [
            "博客格式"
          ]
        },
        "prevItem": {
          "title": "代码块写法",
          "permalink": "/en/blog/代码块写法"
        }
      },
      "content": "[Docusaurus blogging features](https://docusaurus.io/docs/blog) are powered by the [blog plugin](https://docusaurus.io/docs/api/plugins/@docusaurus/plugin-content-blog).\n\nSimply add Markdown files (or folders) to the `blog` directory.\n\nRegular blog authors can be added to `authors.yml`.\n\nThe blog post date can be extracted from filenames, such as:\n\n- `2019-05-30-welcome.md`\n- `2019-05-30-welcome/index.md`\n\nA blog post folder can be convenient to co-locate blog post images:\n\n![Docusaurus Plushie](./docusaurus-plushie-banner.jpeg)\n\nThe blog supports tags as well!\n\n**And if you don't want a blog**: just delete this directory, and use `blog: false` in your Docusaurus config."
    }
  ]
}