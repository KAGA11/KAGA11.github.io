---
slug: Promise
title: Promise
authors:
  name: 时雨
  title: Promise笔记
  url: https://github.com/KAGA11
  image_url: https://github.com/KAGA11.png
tags: [JS]
---
# Promise笔记

### 1.回调地狱

​		回调函数中嵌套回调

```js
function fn1(n){
  	n = n + 1
    fn2(n)
    function fn2(n){
        n = n + 2
        fn3(n)
        console.log('2:',n);
        function fn3(n){
            n = n + 3
            fn4(n)
            console.log('3:',n);
            function fn4(n){
                n = n + 4
                console.log('4:',n);
            }
        }
    }
    console.log('1:',n);
}
        
    fn1(10) // 20 16 13 11
```



##### 	**为什么需要Promise**

​		Promise解决了回调地狱



### 2.Promise 的基本使用

##### 参数

Promise 作为一个构造函数, 接受一个函数作为参数

- 在参数函数中有两个参数

- - resolve: 成功函数
  - reject: 失败函数

```js
 const p = new Promise((resolve,reject)=>{})
 console.dir(p);

//[[Prototype]]: Promise 
//[[PromiseState]]: "pending"
//[[PromiseResult]]: undefined
```

##### 属性

promise实例有两个属性

- state: 状态
- result: 结果



#### 1) Promise的状态（state）

第一种状态: pending (准备)

第二种状态: fulfilled (已完成)

第三种状态: rejected (拒绝)



#### 2) Promise状态的改变

通过调用resolve() reject() 改变Promise的状态

##### resolve() 

使当前Promise状态改成fulfilled

```js
const p = new Promise((resolve,reject)=>{
        resolve()
 })
console.dir(p);
//[[PromiseState]]: "fulfilled"
```



##### reject()	

使当前Promise状态改成 rejected

```js
const p = new Promise((resolve,reject)=>{
        reject()
 })
console.dir(p);
//[[PromiseState]]: "rejected"
```



Promise状态只能改变一次

```js
const p = new Promise((resolve,reject)=>{
				resolve()
        reject()
 })
console.dir(p);
//[[PromiseState]]: "fulfilled
```



#### 3) Promise 的结果(result)

##### resolve()

 通过调用 resolve() 传递参数,改变 当前Promise对象的结果

```js
const p = new Promise((resolve,reject)=>{
      resolve('成功的结果')
})
console.dir(p);
//[[PromiseState]]: "fulfilled
//[[PromiseResult]]: "成功的结果"
```

##### reject()

```js
const p = new Promise((resolve,reject)=>{
      resolve('失败的结果')
})
console.dir(p);
//[[PromiseState]]: "rejected"
//[[PromiseResult]]: "失败的结果"
```



### 3. Promise的方法

实例使用原型的方法

#### 1) then方法

##### 参数 (两个)

​	1：函数 (执行成功(fulfilled)的语句)

​	2:   也是函数(执行失败(rejected)的语句)

##### 返回值 

​	是一个Promise对象

```js
// p.then(()=>{ }, ()=>{ })
const p = new Promise((resolve,reject)=>{
    resolve('成功的结果')
    //reject('失败的结果')
})
p.then(()=>{
    console.log('成功时调用');
},()=>{
    console.log('失败时调用');
})
console.dir(p);
//"成功时调用"
```

##### then方法的形参

可以看到then方法里的形参返回的是resolve里的参数

```js
const p = new Promise((resolve,reject)=>{
    // resolve('成功的结果')
    reject('失败的结果')
})
p.then((value)=>{
    console.log('成功时调用',value);
},(error)=>{
    console.log('失败时调用',error);
})
console.dir(p);
//成功时调用 成功的结果
//失败时调用 失败的结果
```

返回值 是一个Promise对象

 设一个t接住 p.then(),可以发现t还是一个promise对象

```js
const t = p.then((value)=>{
    console.log('成功时调用',value);
},(error)=>{
    console.log('失败时调用',error);
})

console.dir(t);

// 这里t的状态是pending
```

##### 链式操作

由于then()方法依旧返回Promise实例 所以可以多用几个then接住

```
new Promise((resolve,reject)=>{}).then().then()
```



Promise的状态不改变,不执行then()方法

```js
// 这里的then不执行
new Promise((resolve,reject)=>{
  resolve('成功')
  // reject('失败')
}).then(()=>{
    console.log('成功时调用');
  		return '第一个then成功了'
},()=>{
    console.log('失败时调用');
}).then(()=>{
    console.log('成功时调用');
},()=>{
    console.log('失败时调用');
})
console.dir(p);
```

第一个 then结束后 状态是pending. 此时不能直接调用第二个then()方法执行, 

在then()方法中  `return ` 可以将实例的状态改成fulfilled



####  2)catch方法

 catch中的参数函数在什么时候被执行：

​		当Promise的状态改为rejcted.被执行
​		当Promise执行体中出现代码错误时,被执行

```js
p.catch(()=>{})
```

```js
 const p = new Promise((resolve,reject)=>{
    // resolve(' promise成功')
    reject('promise失败')
})
p.catch(()=>{
  	console.log('失败');
})
console.dir(p);
// 失败
```





### 4.用Promise修改回调地狱

原代码

```js
function fn1(n){
  	n = n + 1
    fn2(n)
    function fn2(n){
        n = n + 2
        fn3(n)
        console.log('2:',n);
        function fn3(n){
            n = n + 3
            fn4(n)
            console.log('3:',n);
            function fn4(n){
                n = n + 4
                console.log('4:',n);
            }
        }
    }
    console.log('1:',n);
}
        
    fn1(10) // 20 16 13 11
```



Promise:

```js
const p = new Promise((resolve, reject) => {
    resolve(10);
}).then((value) => {
    value = value + 1;
    return value;
}).then((value) => {
    value = value + 2;
    return value;
}).then((value) => {
    value = value + 3;
    return value;
}).then((value) => {
    value = value + 4;
    return value;
})
  .catch((error) => {
    console.log('计算失败');
});

p.then((final) => {
    console.log(final);
});
```

