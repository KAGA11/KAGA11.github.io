# HTML

#### 解释下HTML5语义化标签的含义和用法

header footer nav ..

便于SEO搜索引擎优化 以及 无障碍阅读

#### html5的新特性

HTML5 不仅引入了语义化标签，还包括许多其他特性和改进，以下是一些重要的 HTML5 特性：

### 1. 新的表单控件和属性
HTML5 添加了许多新的表单控件和属性，增强了表单的功能和用户体验。

- **日期选择控件**

  ```html
  <input type="date">
  ```

- **颜色选择控件**

  ```html
  <input type="color">
  ```

- **范围选择控件**

  ```html
  <input type="range" min="0" max="100">
  ```

- **电子邮件和 URL 验证**

  ```html
  <input type="email">
  <input type="url">
  ```

- **占位符**

  ```html
  <input type="text" placeholder="请输入文本">
  ```

### 2. 音频和视频支持
HTML5 通过 `<audio>` 和 `<video>` 标签提供了对音频和视频的原生支持，无需第三方插件。

- **音频**

- **视频**

  

### 3. 本地存储
HTML5 提供了本地存储机制，可以在客户端存储数据。

- **localStorage**

  ```javascript
  localStorage.setItem('key', 'value');
  var value = localStorage.getItem('key');
  ```

- **sessionStorage**

  ```javascript
  sessionStorage.setItem('key', 'value');
  var value = sessionStorage.getItem('key');
  ```

### 4. 画布 (Canvas)




### 前端缓存

浏览器缓存、HTTP缓存和Web Storage都是用于在客户端存储数据以提高性能和用户体验的技术，但它们在实现方式、使用场景和持久性方面有一些区别。下面是它们的详细介绍和对比。

### 浏览器缓存（Browser Cache）

浏览器缓存是一种存储机制，用于保存静态资源（如HTML、CSS、JavaScript、图像等），以减少对服务器的重复请求，提升网页加载速度。

- **工作原理**：当浏览器请求资源时，会首先检查本地缓存是否有该资源的有效副本。如果有，则直接从缓存中读取资源，而不是向服务器请求。
- **控制方式**：通过HTTP头部（如Cache-Control、Expires、ETag、Last-Modified）来控制资源的缓存行为和过期时间。
- **用途**：减少服务器负载、加快页面加载速度。

### 强缓存 200 不向服务端发请求

- **Cache-Control**：一个常用的HTTP头，用于指定缓存指令。例如：
  ```http
  Cache-Control: max-age=3600, must-revalidate
  ```
  表示资源在缓存中可以保存3600秒，但在使用前必须验证其有效性。

- **Expires**：指定资源的过期时间，是一个绝对时间点。例如：
  ```http
  Expires: Wed, 21 Oct 2023 07:28:00 GMT
  ```

#### 协商: 304 向服务端发请求 转到缓存304

- **ETag**：一个唯一标识符，用于标识资源的版本。当资源更新时，ETag也会更新。例如：

  ```http
  ETag: "34aa387-d-1568eb00"
  ```

- **Last-Modified**：表示资源的最后修改时间。例如：
  ```http
  Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
  ```

### 1. 强缓存 `Expires` 和 `Cache-Control`

- **Expires**：指定资源过期的绝对时间。浏览器在该时间前都直接从缓存读取资源。

  ```
  Expires: Wed, 21 Oct 2023 07:28:00 GMT
  ```
  
- **Cache-Control**：提供更细粒度的控制。常用的指令有 `max-age`、`public`、`private`、`no-cache` 和 `no-store`。

  ```
  Cache-Control: max-age=3600, public
  ```

### 2. 协商缓存 `ETag` 和 `Last-Modified`

- **ETag**：服务器生成的资源标识符。浏览器在请求时会带上 `If-None-Match` 头部，服务器通过比较 ETag 判断资源是否更新。

  ```
  ETag: "34aa387-d-1568eb00"
  ```
  
- **Last-Modified**：资源的最后修改时间。浏览器在请求时会带上 `If-Modified-Since` 头部，服务器通过比较时间判断资源是否更新。

  ```
  Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
  ```





##### localStorage 和 sessionStorage 和 cookie

localStorage 和 sessionStorage 是HTML5的新特性, 之前使用cookie.

优点：不会随着HTTP请求发向服务器,减轻负载

webStorage 不会随着HTTP发到服务器 cookie会发送 大概2KB

lcoalStorgae 储存在本地

session在会话 关闭浏览器会消除

##### 前端可以储存cookie吗

可以 			document.cookie  = 



# CSS

 **flex:1 是什么意思**

Flex-grow:1 flex-shrink:0 flex-basis: 0%

##### css两种盒子模型 box-sizing

1. content-box: 总宽度= 两边boarder + content(width:200px) + 两边padding
2. boarder-box 总宽度(200px) = 涵盖了 两边boarder + content + 两边padding



##### margin padding参数的顺序

```
上下20px		左右10px
margin: 20px 10px 
上20px 左右10px 	下30px
margin: 20px 10px 30px;
上20px 右10px 下30px 左40px 顺时针
margin:  20px 10px 30px 40px;
```

##### display:none |  visibility: hidden | opacity:0的区别

- **`display: none`**：元素不占空间，无法交互。
- **`visibility: hidden`**：元素占空间，但不可见，无法交互。
- **`opacity: 0`**：元素完全透明，仍占空间并可以交互。



position:absolute的定位: 通过指定元素相对于最近的**非 static** 定位祖先元素,父元素都没写 相当于**视口**

position:fixed 通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置



### 水平垂直居中实现

### 	flex布局

```html
<style>
.content{
    display: flex;
    height: 100vh;
    justify-content: center;
    align-items: center;
}
.box{
    height: 100px;
    width: 100px;
    background-color: blue;
}
</style>   
<body>
    <div class="content">
        <div class="box"></div>
    </div>
</body>
```

### flex布局 margin：auto

###        绝对定位

```html
<style>
  .content{
      height: 100vh;
      position: relative;
  }
  .box{
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%); // 将正方形平移 使在最中心
      height: 100px;
      width: 100px;
      background-color: blue;
  }
</style>      

<body>
    <div class="content">
        <div class="box"></div>
    </div>
</body>
```

网格居中

```css
display: grid;
justify-items: center; /* Horizontal centering */
align-items: center; /* Vertical centering */
```







### 网格模型

```html
<style>
      .grid-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: auto;
      gap: 10px;
      padding: 10px;
      background-color: #f0f0f0;
    }

    .grid-item {
      background-color: #4caf50;
      color: white;
      padding: 20px;
      text-align: center;
      font-size: 1.5em;
      border-radius: 5px;
    }
</style>

<div class="grid-container">
  <div class="grid-item">1</div>
  <div class="grid-item">2</div>
  <div class="grid-item">3</div>
  <div class="grid-item">4</div>
  <div class="grid-item">5</div>
  <div class="grid-item">6</div>
</div>
```



####  **左侧固定** **右侧自适应**

父元素**display flex**

左侧**500px** 右侧**flex:1**



#### rem

`rem`（root em）是一种相对长度单位，常用于 CSS 中来实现响应式设计和可访问性。它的值相对于根元素的字体大小（即 HTML 元素的字体大小），而不是相对于当前元素的字体大小。

### 1. 基本概念

- **rem**：相对于根元素（`<html>`）的字体大小。
- **em**：相对于当前元素的字体大小。

### 2. 默认值

默认情况下，根元素的字体大小通常为 16 像素。

### 3. 使用示例

#### 基本用法

```css
html {
  font-size: 16px; /* 默认大小 */
}

body {
  font-size: 1rem; /* 16px */
}

h1 {
  font-size: 2rem; /* 32px */
}

p {
  font-size: 0.875rem; /* 14px */
}
```

#### 调整根字体大小

通过调整根元素的字体大小，可以实现响应式设计。例如，使用媒体查询来调整根字体大小：

```css
html {
  font-size: 16px; /* 默认大小 */
}

@media (min-width: 768px) {
  html {
    font-size: 18px; /* 大屏设备上的字体大小 */
  }
}

@media (min-width: 1024px) {
  html {
    font-size: 20px; /* 更大屏设备上的字体大小 */
  }
}

body {
  font-size: 1rem; /* 根据根字体大小变化 */
}

h1 {
  font-size: 2rem;
}

p {
  font-size: 0.875rem;
}
```

在这个示例中，当屏幕宽度达到 768 像素时，根字体大小变为 18 像素；当屏幕宽度达到 1024 像素时，根字体大小变为 20 像素。这样可以实现响应式的字体大小调整。

### 4. rem 与 em 的区别

- **rem**：相对于根元素的字体大小，具有全局一致性。无论元素嵌套层次如何，其值都保持一致。
- **em**：相对于当前元素的字体大小，具有局部继承性。嵌套元素会继承其父元素的字体大小，并相对调整。

#### em 示例

```css
.parent {
  font-size: 16px;
}

.child {
  font-size: 2em; /* 32px，因为父元素的字体大小是 16px */
}

.grandchild {
  font-size: 0.5em; /* 16px，因为父元素的字体大小是 32px */
}
```

在这个示例中，`.child` 元素的字体大小是 32 像素（2em），而 `.grandchild` 元素的字体大小是 16 像素（0.5em），这是因为 `em` 是相对当前元素的字体大小计算的。

### 5. rem 的优点

- **一致性**：由于 `rem` 是相对于根元素的字体大小，所以在整个文档中保持一致性和可预测性。
- **可访问性**：通过调整根元素的字体大小，可以全局调整页面的所有字体大小，这对于实现响应式设计和提高可访问性非常有用。
- **简化计算**：使用 `rem` 可以避免嵌套元素的字体大小层层叠加计算，简化了 CSS 的维护。



# JS 

### ES6新特性

### 1. 块级作用域和变量声明
#### `let` 和 `const`
- `let` 用于声明块级作用域的变量。
- `const` 用于声明常量，值一旦赋值后不能再修改。

```javascript
let a = 10;
const b = 20;

if (true) {
    let a = 30;
    const b = 40;
    console.log(a); // 30
    console.log(b); // 40
}

console.log(a); // 10
console.log(b); // 20
```

### 2. 箭头函数
简洁的函数语法，且不绑定 `this` 箭头函数的this是上下文的this

箭头函数没有自己的 `arguments` 对象

箭头函数不能用作构造函数(比如 function Person)，尝试使用 `new` 会抛出错误(const p = new Person 需要普通函数)

```javascript
const add = (x, y) => x + y;
console.log(add(2, 3)); // 5
```

### 3. 模板字符串
多行字符串和嵌入表达式的语法。

```javascript
const name = 'John';
const greeting = `Hello, ${name}!`;
console.log(greeting); // Hello, John!
```

### 4. 解构赋值
从数组或对象中提取值，并将其分配给变量。

```javascript
// 数组解构
let [a, b] = [1, 2];
console.log(a); // 1
console.log(b); // 2

// 对象解构
const obj = { name: 'John', age: 30 };
let { name, age } = obj;
console.log(name); // John
console.log(age); // 30
```

### 5. 扩展运算符
```javascript
// 数组展开
let arr = [1, 2, 3];
let newArr = [...arr, 4, 5];
console.log(newArr); // [1, 2, 3, 4, 5]

// 对象展开
let obj1 = { a: 1, b: 2 };
let obj2 = { ...obj1, c: 3 };
console.log(obj2); // { a: 1, b: 2, c: 3 }
```

### 6. 类（Classes）
ES6 引入了基于原型的继承的类语法糖。

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
    }
}

const john = new Person('John', 30);
john.greet(); // Hello, my name is John and I am 30 years old.
```

#### 问: 你说的这个我不是很理解 以前的js没有类这个概念吗 还是只是没有语法糖

在 ES6（ECMAScript 2015）之前，JavaScript 确实没有类（class）的语法，但它仍然支持面向对象编程，通过使用函数和原型链来实现继承和对象创建。ES6 引入了类的语法糖，使得定义和继承类的语法更加简洁和易读，但实际上，这些类的底层机制仍然基于原型。

#### ES6 之前的面向对象编程

在 ES6 之前，我们通常通过构造函数和原型链来创建对象和实现继承：

##### 构造函数和原型链

```javascript
// 构造函数
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// 在原型上添加方法
Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

const john = new Person('John', 30);
john.greet(); // Hello, my name is John and I am 30 years old.
```

##### 继承

```javascript
function Student(name, age, grade) {
    // 调用父类构造函数
    Person.call(this, name, age);
    this.grade = grade;
}

// 设置继承关系
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

// 在子类原型上添加方法
Student.prototype.study = function() {
    console.log(`${this.name} is studying in grade ${this.grade}.`);
};

const jane = new Student('Jane', 22, 'A');
jane.greet(); // Hello, my name is Jane and I am 22 years old.
jane.study(); // Jane is studying in grade A.
```

#### ES6 类语法

ES6 引入了 `class` 关键字，这是一种更加简洁和直观的定义类和继承的方式。尽管语法上看起来像是面向对象编程语言中的类，但底层仍然使用原型链机制。

#### 定义类

```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
    }
}

const john = new Person('John', 30);
john.greet(); // Hello, my name is John and I am 30 years old.
```

#### 类继承

```javascript
class Student extends Person {
    constructor(name, age, grade) {
        super(name, age); // 调用父类的构造函数
        this.grade = grade;
    }

    study() {
        console.log(`${this.name} is studying in grade ${this.grade}.`);
    }
}

const jane = new Student('Jane', 22, 'A');
jane.greet(); // Hello, my name is Jane and I am 22 years old.
jane.study(); // Jane is studying in grade A.
```

### 总结

- **ES6 之前**：通过构造函数和原型链来实现对象创建和继承。这种方式虽然灵活，但语法较为复杂和冗长。
- **ES6 之后**：引入了类的语法糖，使得定义类和继承更加直观和简洁，但本质上仍然基于原型机制。

### 7. 模块（Modules）

es6相比cjs在模块化上提升

#####  静态分析

- **ES6**：模块是**静态**的，导入和导出语句在编译时就能确定。这使得工具能够在编译阶段进行静态分析，有助于优化和提升性能。
- **CJS**：模块是**动态**的，导入和导出在运行时确定，导致静态分析的难度增加



### 8. Promise
用于处理异步操作。

```javascript
const promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve('Success!'), 1000);
});

promise.then(result => console.log(result)); // 1秒后输出: Success!
```

三个状态（pending fulfilled rejected）

方法 then catch finally

### 9. 默认参数

为函数参数设置默认值。

```javascript
function greet(name = 'Guest') {
    console.log(`Hello, ${name}!`);
}

greet(); // Hello, Guest!
greet('John'); // Hello, John!
```

### 10. for...of 循环
用于遍历可迭代对象（如数组、字符串等）。

```javascript
let arr = [1, 2, 3];
for (let value of arr) {
    console.log(value); // 1, 2, 3
}
```









### 数组的常用方法

JavaScript 中的数组对象提供了多种方法来操作和处理数组。以下是一些常用的数组方法及其简单示例：

### 1. 创建数组

#### `Array.from()`
从类数组或可迭代对象创建一个新的数组实例。

```javascript
const arr = Array.from('hello');
console.log(arr); // 输出: ['h', 'e', 'l', 'l', 'o']
```

### 2. 添加和删除元素

#### `push()`
在数组末尾添加一个或多个元素，返回数组的新长度。

```javascript
const arr = [1, 2, 3];
arr.push(4);
console.log(arr); // 输出: [1, 2, 3, 4]
```

#### `pop()`
移除数组中的最后一个元素，返回该元素。

```javascript
const arr = [1, 2, 3, 4];
arr.pop();
console.log(arr); // 输出: [1, 2, 3]
```

#### `unshift()`
在数组的开头添加一个或多个元素，返回数组的新长度。

```javascript
const arr = [1, 2, 3];
arr.unshift(0);
console.log(arr); // 输出: [0, 1, 2, 3]
```

#### `shift()`
移除数组中的第一个元素，返回该元素。

```javascript
const arr = [1, 2, 3];
arr.shift();
console.log(arr); // 输出: [2, 3]
```

#### `splice()`
通过删除或替换现有元素和/或添加新元素来更改一个数组的内容。

```javascript
const arr = [1, 2, 3, 4];
arr.splice(2, 1, 'a', 'b');
console.log(arr); // 输出: [1, 2, 'a', 'b', 4]
```

### 3. 访问元素

#### `includes()`
判断数组是否包含某个元素，返回布尔值。

```javascript
const arr = [1, 2, 3];
console.log(arr.includes(2)); // 输出: true
console.log(arr.includes(4)); // 输出: false
```

#### `indexOf()`
返回数组中首次出现的指定元素的索引，如果不存在则返回 -1。

```javascript
const arr = [1, 2, 3, 2];
console.log(arr.indexOf(2)); // 输出: 1
console.log(arr.indexOf(4)); // 输出: -1
```

#### `lastIndexOf()`
返回数组中最后出现的指定元素的索引，如果不存在则返回 -1。

```javascript
const arr = [1, 2, 3, 2];
console.log(arr.lastIndexOf(2)); // 输出: 3
console.log(arr.lastIndexOf(4)); // 输出: -1
```

### 4. 迭代方法

#### `forEach()`
对数组中的每个元素执行一次提供的函数。

```javascript
const arr = [1, 2, 3];
arr.forEach((element) => {
    console.log(element);
});
// 输出:
// 1
// 2
// 3
```

#### `map()`
创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。

```javascript
const arr = [1, 2, 3];
const mappedArr = arr.map((element) => element * 2);
console.log(mappedArr); // 输出: [2, 4, 6]
```

#### `filter()`
创建一个新数组，其中包含所有通过提供函数测试的元素。

```javascript
const arr = [1, 2, 3, 4];
const filteredArr = arr.filter((element) => element % 2 === 0);
console.log(filteredArr); // 输出: [2, 4]
```

#### `reduce()`
对数组中的每个元素执行一个提供的函数，将其结果汇总为单个返回值。

```javascript
const arr = [1, 2, 3, 4];
const sum = arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
console.log(sum); // 输出: 10
```

#### `every()`
测试数组中的所有元素是否都通过了提供的函数的测试，返回布尔值。

```javascript
const arr = [1, 2, 3, 4];
const allEven = arr.every((element) => element % 2 === 0);
console.log(allEven); // 输出: false
```

#### `some()`
测试数组中的至少一个元素是否通过了提供的函数的测试，返回布尔值。

```javascript
const arr = [1, 2, 3, 4];
const someEven = arr.some((element) => element % 2 === 0);
console.log(someEven); // 输出: true
```

### 5. 查找元素

#### `find()`
返回数组中满足提供的测试函数的第一个元素的值，否则返回 `undefined`。

```javascript
const arr = [1, 2, 3, 4];
const found = arr.find((element) => element > 2);
console.log(found); // 输出: 3
```

#### `findIndex()`
返回数组中满足提供的测试函数的第一个元素的索引，否则返回 -1。

```javascript
const arr = [1, 2, 3, 4];
const index = arr.findIndex((element) => element > 2);
console.log(index); // 输出: 2
```

### 6. 连接和切片

#### `concat()`
合并两个或多个数组，不改变现有数组，返回一个新数组。

```javascript
const arr1 = [1, 2];
const arr2 = [3, 4];
const combinedArr = arr1.concat(arr2);
console.log(combinedArr); // 输出: [1, 2, 3, 4]
```

#### `join()`
将数组的所有元素连接成一个字符串。

```javascript
const arr = [1, 2, 3];
const str = arr.join('-');
console.log(str); // 输出: "1-2-3"
```

#### `slice()`
返回一个新数组，包含从开始索引到结束索引（不包括结束索引）的数组元素。

```javascript
const arr = [1, 2, 3, 4];
const slicedArr = arr.slice(1, 3);
console.log(slicedArr); // 输出: [2, 3]
```

#### `flat()`
按指定深度递归地将数组展平，并返回一个新数组。

```javascript
const arr = [1, [2, [3, [4]]]];
const flattenedArr = arr.flat(2);
console.log(flattenedArr); // 输出: [1, 2, 3, [4]]
```

#### `flatMap()`
先对数组中的每个元素执行一个提供的函数，然后将结果压缩成一个新数组。

```javascript
const arr = [1, 2, 3];
const flatMappedArr = arr.flatMap(x => [x, x * 2]);
console.log(flatMappedArr); // 输出: [1, 2, 2, 4, 3, 6]
```

### 7. 排序和反转

#### `sort()`
对数组中的元素进行原地排序并返回该数组。

```javascript
const arr = [3, 1, 4, 1, 5];
arr.sort((a, b) => a - b);
console.log(arr); // 输出: [1, 1, 3, 4, 5]
```

#### `reverse()`
将数组中的元素原地反转，并返回该数组。

```javascript
const arr = [1, 2, 3];
arr.reverse();
console.log(arr); // 输出: [3, 2, 1]
```

### 8. 其他方法

#### `fill()`
用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。

```javascript
const arr = [1, 2, 3, 4];
arr.fill(0, 1, 3);
console.log(arr); // 输出: [1, 0, 0, 4]
``
```



### ES6新特性

ECMAScript 6 (ES6)，也称为 ECMAScript 2015，是JavaScript的一次重要更新，带来了许多新特性和改进。以下是一些主要的新特性：

1. **let 和 const 声明**：
   - `let`：用于声明块级作用域变量。
   - `const`：用于声明常量，值一旦赋值就不能再修改。

   ```javascript
   let x = 10;
   const y = 20;
   ```

2. **箭头函数**：
   - 简洁的函数定义方式，并且不绑定自己的 `this`。

   ```javascript
   const add = (a, b) => a + b;
   ```

3. **模板字符串**：
   - 使用反引号 (`) 包含字符串，可以嵌入表达式和多行字符串。

   ```javascript
   const name = 'John';
   const greeting = `Hello, ${name}!`;
   ```

4. **解构赋值**：
   - 可以从数组或对象中提取值，并赋值给变量。

   ```javascript
   // 数组解构
   const [a, b] = [1, 2];
   // 对象解构
   const {name, age} = {name: 'John', age: 30};
   ```
   
5. **默认参数**：
   - 函数参数可以有默认值。

   ```javascript
   function greet(name = 'Guest') {
       return `Hello, ${name}!`;
   }
   ```

6. **扩展运算符和剩余参数**：
   - 扩展运算符用于展开数组或对象。
   - 剩余参数用于将多个参数合并为一个数组。

   ```javascript
   // 扩展运算符
   const arr = [1, 2, ...[3, 4]];
   
   // 剩余参数
   function sum(...numbers) {
       return numbers.reduce((acc, num) => acc + num, 0);
   }
   ```

7. **对象字面量的简写**：
   - 简化对象属性和方法的定义。

   ```javascript
   const name = 'John';
   const person = {
       name,
       greet() {
           console.log('Hello!');
       }
   };
   ```

8. **类 (Class)**：
   - 基于原型的面向对象编程语法糖。

   ```javascript
   class Person {
       constructor(name) {
           this.name = name;
       }
       greet() {
           console.log(`Hello, ${this.name}!`);
       }
   }
   ```

9. **模块 (Modules)**：
   - 用于模块化JavaScript代码，使用 `import` 和 `export` 关键字。

   ```javascript
   // 导出模块
   export const name = 'John';
   export function greet() {
       console.log('Hello!');
   }
   
   // 导入模块
   import {name, greet} from './module.js';
   ```

10. **Promise**：
    - 用于处理异步操作。

    ```javascript
    const promise = new Promise((resolve, reject) => {
        setTimeout(() => resolve('Done!'), 1000);
    });
    
    promise.then(result => console.log(result));
    ```

这些特性使得JavaScript更强大、更简洁，也更易于编写和维护。



## 变量提升 基本数据类型 函数 函数表达式(箭头函数) 类

JavaScript 的变量提升（Hoisting）是一个概念，它指的是变量和函数声明在编译阶段被提升到其所在作用域的顶部，但初始化操作不会提升。不同的声明方式（`var`, `let`, `const`），以及函数声明和类声明的提升行为各有不同。

### 1. `var` 的变量提升

使用 `var` 声明的变量会被提升到其所在函数或全局作用域的顶部，但不会被初始化。

```javascript
console.log(a); // 输出: undefined
var a = 10;
console.log(a); // 输出: 10
```

上面的代码相当于：

```javascript
var a;
console.log(a); // 输出: undefined
a = 10;
console.log(a); // 输出: 10
```

### 2. `let` 和 `const` 的变量提升

`let` 和 `const` 声明的变量也会被提升到作用域顶部，但它们在声明之前不能被访问，会出现 `Temporal Dead Zone`（暂时性死区）的错误。

```javascript
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 20;
console.log(b); // 输出: 20

console.log(c); // ReferenceError: Cannot access 'c' before initialization
const c = 30;
console.log(c); // 输出: 30
```

### 3. 函数声明的提升

函数声明会被提升到其所在作用域的顶部，因此可以在声明之前调用。

```javascript
console.log(add(2, 3)); // 输出: 5

function add(x, y) {
  return x + y;
}
```

### 4. 函数表达式的提升

函数表达式中的变量声明会被提升，但赋值不会被提升，因此在声明之前调用会出现错误。

```javascript
console.log(subtract); // 输出: undefined
console.log(subtract(5, 2)); // TypeError: subtract is not a function

var subtract = function (x, y) {
  return x - y;
};
```

上面的代码相当于：

```javascript
var subtract;
console.log(subtract); // 输出: undefined
console.log(subtract(5, 2)); // TypeError: subtract is not a function

subtract = function (x, y) {
  return x - y;
};
```

### 5. 类的提升

类声明不会被提升，在声明之前使用会导致 `ReferenceError`。

```javascript
const instance = new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization

class MyClass {
  constructor() {
    this.name = 'MyClass';
  }
}
```

类表达式的变量声明会被提升，但类本身不会被提升。

```javascript
console.log(MyClass); // 输出: undefined
const instance = new MyClass(); // TypeError: MyClass is not a constructor

var MyClass = class {
  constructor() {
    this.name = 'MyClass';
  }
};
```

### 6. 基本数据类型和对象

基本数据类型（如 `number`, `string`, `boolean`, `null`, `undefined`, `symbol`）和对象的声明遵循上述 `var`, `let`, `const` 的变量提升规则。无论是基本数据类型还是对象，它们的声明方式决定了它们的提升行为。

### 变量提升示例

总结上述规则，我们来看一个综合示例：

```javascript
console.log(x); // 输出: undefined
var x = 5;
console.log(x); // 输出: 5

console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;
console.log(y); // 输出: 10

console.log(z); // ReferenceError: Cannot access 'z' before initialization
const z = 15;
console.log(z); // 输出: 15

console.log(sum(2, 3)); // 输出: 5
function sum(a, b) {
  return a + b;
}

console.log(multiply); // 输出: undefined
console.log(multiply(2, 3)); // TypeError: multiply is not a function
var multiply = function (a, b) {
  return a * b;
};

console.log(Dog); // 输出: undefined
const myDog = new Dog(); // TypeError: Dog is not a constructor
var Dog = class {
  constructor() {
    this.name = 'Dog';
  }
};
```

### 总结

- `var` 声明的变量会被提升到作用域顶部，但初始化不会提升。
- `let` 和 `const` 声明的变量会被提升，但在声明之前访问会导致 `ReferenceError`。
- 函数声明会被提升，可以在声明之前调用。
- 函数表达式和类声明不会被提升，在声明之前调用会导致错误。
- 基本数据类型和对象的声明遵循相应的提升规则。



### 数据扁平化

```js
const arr=[[1,2,3],4,5,[6,7,[8,9]]]
function bianping(nums){
    let res = []
    for (let i = 0; i < nums.length; i++) {
        let item = nums[i]
        Array.isArray(item) ? res=res.concat(bianping(item)) : res.push(item)
    }
    return res
}

function bianpingES6(nums){
    return nums.reduce((res,item) => {
        return res.concat(Array.isArray(item)? bianping(item) : item)
    },[])
}

console.log(bianping(arr));
console.log(bianpingES6(arr));
```



### **`Object`、`Map` 和 `WeakMap` 的区别**：

| 特性           | `Object`                           | `Map`                                | `WeakMap`                            |
| -------------- | ---------------------------------- | ------------------------------------ | ------------------------------------ |
| **键类型**     | 只能是**字符串**或 **`Symbol`**    | 可以是任何类型（包括对象）           | 只能是**对象**类型的引用             |
| **键的顺序**   | 无保证，按插入顺序遍历             | 有插入顺序保证                       | 无保证                               |
| **键的弱引用** | 否                                 | 否                                   | 是，键是弱引用，垃圾回收机制可清除   |
| **键的枚举性** | 可以用 `for...in` 或 `Object.keys` | 可以用 `map.keys()` 获取所有键       | 无法枚举键                           |
| **键的重复性** | 键不能重复，重复会覆盖             | 键不能重复，重复会覆盖               | 键不能重复，重复会覆盖               |
| **性能优化**   | 对少量数据处理更高效               | 对大量数据处理更高效                 | 用于特定场景（如缓存，自动内存管理） |
| **垃圾回收**   | 不会自动处理，必须手动清除         | 不会自动处理，必须手动清除           | 键对象若没有其他引用会被垃圾回收     |
| **常用场景**   | 通常用于存储常规键值对             | 高效处理复杂映射（支持任何类型的键） | 存储依赖对象的临时数据，避免内存泄漏 |
|                |                                    |                                      |                                      |





### 原型链

```js
function Person(name){
    this.name = name
}

const p1 = new Person('john');

console.log(p1.__proto__ === Person.prototype); // true
console.log(Person === p1.__proto__.constructor); // true
console.log(Person.prototype.__proto__ === Object.prototype);// true
```



### 执行顺序 和事件循环

事件循环就是执行顺序的理论

1. **调用栈（Call Stack）**：
   - 调用栈是一个 LIFO（后进先出）的数据结构，用于存储正在执行的函数调用。
   - 当函数被调用时，它会被添加到调用栈顶部。当函数执行完毕后，它会从调用栈中移除。
2. **任务队列（Task Queue）**：
   - 任务队列存储需要在未来执行的任务，通常是由异步操作（如 `setTimeout`、网络请求、事件回调等）引入的。
   - 当调用栈为空时，事件循环会从任务队列中取出一个任务，并将其放入调用栈中执行。
3. **微任务队列（Microtask Queue）**：
   - 微任务队列存储需要在更高优先级下执行的任务，通常是由 `Promise` 等引入的。
   - 微任务队列中的任务在每个宏任务结束后立即执行。

```
setTimeout(()=>{
    console.log('1')
},0)
new Promise((res)=>{
    console.log('2');
    res();
}).then(()=>{
    console.log('3')
})
console.log('4')
// 2 4 3 1 单单创建一个Promise 是同步的        .then()是异步
```

**创建 `Promise` 实例**：

- `new Promise((res) => {...})`：这一行代码创建了一个新的 `Promise` 实例，并立即执行传入的执行函数（executor function）。
- 执行函数中的代码是同步的，所以 `console.log('2')` 会立即执行，输出 `2`。
- 然后执行 `res()`，这只是将 `Promise` 状态变为 `resolved`，但不会立即执行任何异步操作（如 `.then` 中的回调）。



### for in for of区别，为什么

主要区别在于前者遍历对象的可枚举**属性名**，而后者遍历可迭代**对象的值**。前者主要用于普通对象，后者用于数组、字符串、`Map`、`Set` 等可迭代对象。

```js
const list1 = [22,11,33,44]
for(const each of list1){
    console.log(each); //22 11 33 44
}
for(const index in list1){
    console.log(index);// 0 1 2 3
}
const obj ={
    address:'hangzhou',
    name:'bob'
}

for(const key in obj){
    console.log(key); // address name
}

// 普通对象不可迭代值 只可迭代键 因为普通对象的key 是无序的
// for(const value of obj){
//     console.log(value);
// }

// 可迭代对象包括数组 string Set Map 因为Map的key是有序的
const map = new Map(); // Map(2) { 'address' => 'shanghai', 'name' => 'alice' }
map.set('address','shanghai')
map.set('name','alice')
for(const [key,value] of map){
    console.log(`${key} : ${value}`); // address : shanghai 
}

```

 

### 拷贝

浅： 只复制第一层(两个对象一个地址)

**如果我改成 original.b.c = 20 浅拷贝的copy.b.c 也是20 但是深拷贝就是2**

```js
const original = { a: 1, b: { c: 2 } };
const copy1 = Object.assign({}, original);
const copy2 = { ...original };
```

深: 复制所有层级的对象(两个obj各自独立)

```js
const original = { a: 1, b: { c: 2 } };
const copy = JSON.parse(JSON.stringify(original));
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item));
    }
    const clone = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            clone[key] = deepClone(obj[key]);
        }
    }
    return clone;
}
```









## Promise

#### Promise.then的参数

`Promise.prototype.then` 方法是处理 Promise 异步操作的主要方法之一。它可以接受最多两个参数，分别是：

1. **onFulfilled**：在 Promise 被解决（fulfilled）时调用的回调函数。
2. **onRejected**：在 Promise 被拒绝（rejected）时调用的回调函数。

### 参数详解

1. **onFulfilled**：
   - **类型**：函数（可选）
   - **描述**：当 Promise 状态变为 fulfilled 时被调用。该函数接受一个参数，即由 Promise resolve 时传递的值。
   - **返回值**：该函数可以返回一个值，这个值会被包裹在一个新的 Promise 中。如果返回的是一个 Promise，则会等待这个 Promise 被解决后，新的 Promise 才会被解决。

2. **onRejected**：
   - **类型**：函数（可选）
   - **描述**：当 Promise 状态变为 rejected 时被调用。该函数接受一个参数，即由 Promise reject 时传递的原因（通常是一个错误对象）。
   - **返回值**：该函数可以返回一个值，这个值会被包裹在一个新的 Promise 中。如果返回的是一个 Promise，则会等待这个 Promise 被解决后，新的 Promise 才会被解决。如果没有提供这个回调函数或者该回调函数返回一个新的 Promise，链式调用中的下一个 `then` 会接收到这个新的 Promise 的结果。

### 使用示例

```javascript
const promise = new Promise((resolve, reject) => {
  const success = true; // 假设这是异步操作的结果
  if (success) {
    resolve('Operation successful!');
  } else {
    reject('Operation failed!');
  }
});

promise.then(
  (value) => {
    console.log('Fulfilled:', value);
    // 这里可以返回一个新的值或者 Promise
    return 'New value';
  },
  (error) => {
    console.log('Rejected:', error);
  }
).then(
  (value) => {
    console.log('Next fulfillment:', value); // 这里接收到上一个 then 返回的 'New value'
  },
  (error) => {
    console.log('Next rejection:', error);
  }
);
```

### 链式调用

`then` 方法返回一个新的 Promise，这使得链式调用成为可能。每个 `then` 中的 `onFulfilled` 和 `onRejected` 回调函数都会影响后续的 Promise 链。

```javascript
const promise = new Promise((resolve, reject) => {
  resolve('First success');
});

promise
  .then((value) => {
    console.log('First then:', value);
    return 'Second success';
  })
  .then((value) => {
    console.log('Second then:', value);
  });
```

### 错误处理

通过提供 `onRejected` 回调函数，你可以处理 Promise 被拒绝的情况。如果不提供 `onRejected` 回调函数，可以使用 `catch` 方法来处理错误：

```javascript
const promise = new Promise((resolve, reject) => {
  reject('Something went wrong');
});

promise
  .then(
    (value) => {
      console.log('Fulfilled:', value);
    },
    (error) => {
      console.error('Rejected:', error);
    }
  )
  .catch((error) => {
    console.error('Caught by catch:', error);
  });
```

手写race

```js
function promiseRace(promises) {
  return new Promise((resolve, reject) => {
    for (const promise of promises) {
      Promise.resolve(promise)
        .then(resolve)
        .catch(reject);
    }
  });
}
```





### 数组去重	

```javascript
// set
Array.from(new Set(arr))
// filter + index
arr.filter( (item ,index) =>{
    return arr.indexOf(item) === index
})
// reduce
arr.reduce( (acc,cur) =>{
    if (!acc.includes(cur)) {
        acc.push(cur)
    }
    return acc
},[] )
```





### 排序算法

### 1. 冒泡排序（Bubble Sort）

冒泡排序是一种简单的排序算法，通过重复地遍历列表，比较相邻元素并交换它们的位置，如果它们的顺序错误。这一过程会逐渐将最大或最小的元素“冒泡”到列表的一端。

```javascript
function bubbleSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        for (let j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换 arr[j] 和 arr[j + 1]
                [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
            }
        }
    }
    return arr;
}

const arr = [64, 34, 25, 12, 22, 11, 90];
console.log(bubbleSort(arr)); // 输出: [11, 12, 22, 25, 34, 64, 90]
```

### 2. 选择排序（Selection Sort）

选择排序通过反复从未排序部分中选出最小（或最大）的元素，并将其放在已排序部分的末尾。它的主要特点是不断地选择最小元素，并将其移到已排序部分。

```javascript
function selectionSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n - 1; i++) {
        let minIndex = i;
        for (let j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        // 交换 arr[i] 和 arr[minIndex]
        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
    return arr;
}

const arr = [64, 25, 12, 22, 11];
console.log(selectionSort(arr)); // 输出: [11, 12, 22, 25, 64]
```

### 3. 插入排序（Insertion Sort）

插入排序通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序）。

#### 实现

```javascript
function insertionSort(arr) {
    let n = arr.length;
    for (let i = 1; i < n; i++) {
        let key = arr[i];
        let j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
    return arr;
}

const arr = [12, 11, 13, 5, 6];
console.log(insertionSort(arr)); // 输出: [5, 6, 11, 12, 13]
```

### 4. 快速排序（Quick Sort）

快速排序是分治法的一种应用。它通过选择一个“基准”元素，将数组分成比基准小和比基准大的两部分，然后递归地排序这两部分。

#### 实现

```javascript
function quickSort(arr) {
    if (arr.length <= 1) {
        return arr;
    }
    let pivot = arr[Math.floor(arr.length / 2)];
    let left = [];
    let right = [];
    for (let i = 0; i < arr.length; i++) {
        if (i === Math.floor(arr.length / 2)) continue;
        if (arr[i] < pivot) {
            left.push(arr[i]);
        } else {
            right.push(arr[i]);
        }
    }
    return [...quickSort(left), pivot, ...quickSort(right)];
}

const arr = [10, 7, 8, 9, 1, 5];
console.log(quickSort(arr)); // 输出: [1, 5, 7, 8, 9, 10]
```

 

#### 总结

这些基础的排序算法各有优缺点，适用于不同的场景：

- **冒泡排序**、**选择排序** 和 **插入排序**：适合小规模数据集，简单易实现，但性能较差。
- **快速排序** ：适合大规模数据集，具有较好的平均性能。





### setTimeout 和 async/await的输出顺序

Promises 和 `async/await` 放在微任务		setTimeout放在宏任务

```js
async function asyncFunc() {
  console.log('1'); //同步代码在执行栈
  setTimeout(() => console.log('2'), 0); //宏
  console.log('6');
  await new Promise((resolve) => resolve('3')).then(console.log); // await回暂停并回到上文导致输出5 并执行完所有同步代码
  console.log('4'); // 
  }

  asyncFunc();
  console.log('5');//同步代码在执行栈
// 1 6 5 3 4 2

// 但是普通promise是不会直接回到上文的 他会跳过当前command到后续的全局变量 然后跳出
function asyncFunc() {
    console.log('1'); //同步代码在执行栈
    setTimeout(() => console.log('2'), 0); //宏
    console.log('6');
    new Promise((resolve) => resolve('3')).then(console.log); 
    new Promise( resolve => resolve('8'))
        .then(num => num)
        .then(num => console.log(num))
    console.log('4'); // 
}

asyncFunc();
console.log('5');//同步代码在执行栈
// 1 6 4 5 3 8 2 
```

**高难执行顺序** 

```javascript
var a;
var b = new Promise((resolve, reject) => {
  console.log('promise1');
  setTimeout(() => {
    resolve()
  }, 1000)
}).then(() => {
  console.log('promise2');
}).then(() => {
  console.log('promise3');
}).then(() => {
  console.log('promise4');
})
a = new Promise(async (resolve) => {
  console.log(a);
  await b;
  console.log('a');
  console.log('after1');
  await a;
  resolve(true);
  console.log('after2');
});
console.log('end');
```



### 输出顺序 闭包

```
1. 这段的输出结果是什么
5个5 同时输出 因为var是在全局作用域 并且先执行同步代码 所以i的值先加到5再执行setTimeout
for (var i = 0; i < 5; i++) {
    setTimeout(()=>{
        console.log(i);
    },1000)
 } 

2. 我想要0 1 2 3 4 把var改成let 这样是块级作用域
for (let i = 0; i < 5; i++) {
    setTimeout(()=>{
        console.log(i);
    },1000)
 }  
3. 我想要每一秒输出一个结果0 1 2 3 4, 改成1000*i 这样会记录每秒钟的i的值 比如i=1 1000*i = 1000 那么在1000时输出1
i=2 1000 * 2 = 2000 那么在2000秒输出2
for (let i = 0; i < 5; i++) {
    setTimeout(()=>{
        console.log(i);
    },1000 * i)
 } 
4.我不想用let 就是var 我怎么实现3的效果呢 闭包
for (var i = 0; i < 5; i++) {
    (function(j){
        setTimeout(()=>{
            console.log(j);
        },1000 * j)
    })(i)
}  

for (var i =0; i < 5; i++ ){
    function logNum(j){
    return function(){
        console.log(j);
    }
}
    setTimeout(logNum(i),1000*i)
}
```



async 和 defer

 `async` 脚本加载完成，会立即执行。此时，HTML 解析会暂时**中断**，直到脚本执行完毕后再继续。

 `defer` 脚本会等到 HTML **解析完毕**（DOM 完成构建）后再依次执行，保证脚本不会干扰 HTML 解析流程。



## 性能优化总结

1.压缩和优化JS、img、css资源

2.异步加载js

3.使用服务器缓存

4.网络: CDN 

5.减小DOM复杂度



# React

#### React特性

1. **组件化**
2. **虚拟 DOM**：React 使用虚拟 DOM 来优化性能。虚拟 DOM 是 React 内部维护的一个轻量级副本，当状态或属性改变时，React 先更新虚拟 DOM，然后通过 Diff 算法比较新旧虚拟 DOM 的差异，只将真正有变化的部分同步到实际的 DOM 上。
3. **单向数据流（Unidirectional Data Flow）**：React 采用单向数据流，父组件通过属性（props）将数据传递给子组件，而子组件不能直接修改父组件的数据。
4. **JSX 语法**
5. **声明式 UI**：React 通过声明式编程来构建用户界面。开发者只需声明界面应该如何渲染，React 会根据数据的变化自动更新界面，避免了手动 DOM 操作。
6. **服务端渲染（SSR）**：React 支持服务端渲染，可以生成静态 HTML，减少首次加载时间，提升 SEO 效果。Next.js 是一个流行的基于 React 的框架，它提供了服务端渲染的解决方案。
7. **Hooks**：Hooks 是 React 16.8 引入的一项特性，允许在函数组件中使用状态（`useState`）和其他 React 特性（比如 `useEffect`、`useContext`）。Hooks 大大简化了函数组件的使用，使得函数组件可以取代许多场景下的类组件。



### React渲染阶段

React 的渲染流程可以分为两个主要阶段：**Render 阶段** 和 **Commit 阶段**。

React组件的更新过程

render 阶段

        1. 调用组件的render方法 生成虚拟DOM树
        2. reconciliation 协调 基于diff算法 比较新旧虚拟DOM树的不同 
        3. 生成 Fiber 树

Commit 阶段

        1. 将Fiber树的变化 更新实际的DOM
        2. 执行副作用 useEffect
        3. 更新Ref

### 1. 渲染流程概述

React 的渲染流程分为以下几个阶段：

- **Render 阶段**：在此阶段，React 会计算和生成新的虚拟 DOM，找到与上次渲染的差异。
- **Commit 阶段**：将计算出的差异应用到真实 DOM 中，完成界面的更新。

在更详细的层面上，React 渲染过程包括以下步骤：

1. **调度更新**：当状态或 props 发生变化时，React 会将更新放入调度队列，并通过调度器（scheduler）安排更新。
2. **Render 阶段（Diff 阶段）**：React 在此阶段生成新的虚拟 DOM 树，并计算出哪些部分需要更新。这一过程是**可中断的**，React 可以根据需要暂停或重新开始，以确保高优先级任务（如用户交互）不会被阻塞。
3. **Commit 阶段（DOM 更新阶段）**：React 将 Render 阶段生成的差异应用到真实 DOM 中，并触发生命周期钩子函数（如 `componentDidMount`、`componentDidUpdate` 等）。这一阶段是**不可中断的**，一旦开始就会完整地完成。

### 2. Render 阶段（可中断）

Render 阶段的主要目标是计算哪些部分的界面需要更新，并生成变更所需的虚拟 DOM 树。该阶段分为以下步骤：

- **创建更新单元**：每次更新触发后，React 会根据组件树的结构生成一系列更新单元，称为 **Fiber 节点**。
- **Fiber 树构建与 Diff**：React 将创建的 Fiber 树与上次渲染的 Fiber 树进行比较，通过 **Diff 算法**（虚拟 DOM diffing）确定哪些组件或 DOM 节点发生了变化。
- **任务调度与优先级控制**：Render 阶段是**可中断的**，React 使用调度器（scheduler）在浏览器的空闲时间执行任务，确保高优先级任务（如用户输入）不会被阻塞。

Render 阶段的产物是一个待提交的更新单元列表（包含需要更新的 DOM 节点和更新数据），供 Commit 阶段应用到真实 DOM 中。

### 3. Commit 阶段（不可中断）

Commit 阶段的目标是将 Render 阶段生成的更新实际应用到真实 DOM 中。此阶段的关键步骤如下：

- **应用更新到 DOM**：React 根据 Render 阶段生成的更新单元，直接对 DOM 进行更新操作。
- **触发生命周期钩子**：React 在 DOM 更新完成后触发生命周期钩子，包括 `componentDidMount`、`componentDidUpdate` 和 `useEffect` 的执行。
- **更新真实 DOM 与界面同步**：此阶段会立即将变更应用到 DOM 中，因此用户可以看到界面的更新效果。

由于 DOM 操作和生命周期钩子执行不可被中断，React 会确保在 Commit 阶段将所有变更完全应用，保证界面的状态一致性。

### 4. 渲染流程图示

整个流程可以用以下步骤来总结：

1. **数据更新**：组件的状态或 props 发生改变，触发一次更新。
2. **调度任务**：React 使用调度器管理更新的优先级，将更新推入调度队列。
3. **Render 阶段**：
   - 生成 Fiber 树，计算新的虚拟 DOM。
   - 使用 Diff 算法与上次的虚拟 DOM 对比，确定变更。
   - 中途可以被高优先级任务打断，分批执行。
4. **Commit 阶段**：
   - 将变更实际应用到真实 DOM。
   - 触发生命周期钩子，使组件完成更新后的处理。
   - 用户看到更新后的界面。

### 5. React Fiber 对渲染流程的优化

React Fiber 是一种将渲染过程分成小块的架构，使渲染过程可以被打断并恢复，支持时间切片和任务调度，带来了以下优化：

- **可中断的渲染**：Render 阶段可以暂停、恢复、终止，确保高优先级任务得到及时响应。
- **任务优先级**：React Fiber 根据任务优先级来调度，提升用户体验。
- **更细粒度的更新控制**：Render 阶段会分阶段渲染子树，提升性能，减少无意义的更新。







#### Class Component 和 Function Component有什么区别

React 中的 Class Component 和 Function Component 是两种创建组件的方式，它们各有特点和使用场景。以下是它们的主要区别：

### Class Component

1. **定义方式**：
   使用 ES6 类定义组件。

   ```javascript
   class MyComponent extends React.Component {
       render() {
           return <div>Hello, World!</div>;
       }
   }
   ```

2. **状态和生命周期**：
   - 使用 `this.state` 管理状态。
   - 使用生命周期方法（如 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 等）。

   ```javascript
   class MyComponent extends React.Component {
       constructor(props) {
           super(props);
           this.state = { count: 0 };
       }
   
       componentDidMount() {
           // 在组件挂载后执行
       }
   
       render() {
           return <div>{this.state.count}</div>;
       }
   }
   ```

3. **使用场景**：
   - 需要使用状态或生命周期方法时使用 Class Component。

### Function Component

1. **定义方式**：
   使用函数定义组件。

   ```javascript
   function MyComponent() {
       return <div>Hello, World!</div>;
   }
   ```

2. **状态和生命周期（通过 Hooks）**：
   - 使用 `useState` 管理状态。
   - 使用 `useEffect` 处理副作用，相当于生命周期方法。

   ```javascript
   import React, { useState, useEffect } from 'react';
   
   function MyComponent() {
       const [count, setCount] = useState(0);
   
       useEffect(() => {
           // 在组件挂载和更新后执行
       }, [count]); // 依赖项
   
       return <div>{count}</div>;
   }
   ```

3. **使用场景**：
   - 更简洁和易读，适合大多数情况。
   - 没有this
   - 使用 Hooks 提供的功能可以替代 Class Component 的状态和生命周期管理。







### React 常见的hooks

### 1. useState

好处

底层

`useState` 是用于在函数组件中引入状态的 Hook。它返回一个状态变量和一个更新状态的函数。

**示例代码：**

```jsx
import React, { useState } from 'react';

function Counter() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}

export default Counter;
```

### 2. useEffect

`useEffect` 是用于处理副作用的 Hook。它可以在组件渲染后执行某些操作，如数据获取、订阅或手动修改 DOM

**示例代码：**

```jsx
import React, { useEffect, useState } from 'react';

function DataFetcher() {
    const [data, setData] = useState(null);

    useEffect(() => {
        fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => setData(data));
    }, []); // 依赖数组为空，表示只在组件挂载和卸载时执行

    return (
        <div>
            {data ? <pre>{JSON.stringify(data, null, 2)}</pre> : <p>Loading...</p>}
        </div>
    );
}

export default DataFetcher;
```

### 3. useContext

`useContext` 是用于在函数组件中访问上下文的 Hook。

父组件修改 子组件会重新渲染

雅虎军规心能优化 3件套的

**示例代码：**

```jsx
import React, { useContext } from 'react';

const MyContext = React.createContext();

function ChildComponent() {
    const value = useContext(MyContext);

    return <div>{value}</div>;
}

function ParentComponent() {
    return (
        <MyContext.Provider value="Hello, Context!">
            <ChildComponent />
        </MyContext.Provider>
    );
}

export default ParentComponent;
```

### 4. useReducer

`useReducer` 是用于替代 `useState` 处理复杂状态逻辑的 Hook。它适用于需要管理多个子值或复杂状态转变的情况。

**示例代码：**

```jsx
import React, { useReducer } from 'react';

const initialState = { count: 0 };

function reducer(state, action) {
    switch (action.type) {
        case 'increment':
            return { count: state.count + 1 };
        case 'decrement':
            return { count: state.count - 1 };
        default:
            throw new Error();
    }
}

function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);

    return (
        <div>
            <p>Count: {state.count}</p>
            <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
            <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
        </div>
    );
}

export default Counter;
```

### 5. useCallback

`useCallback` 是用于返回一个记忆（缓存）的回调函数的 Hook，可以防止在每次渲染时重新创建回调函数，提高性能。

**示例代码：**

```jsx
import React, { useState, useCallback } from 'react';

function ExpensiveCalculation({ calculate }) {
    console.log('Calculating...');
    return <div>Result: {calculate()}</div>;
}

function ParentComponent() {
    const [count, setCount] = useState(0);

    const calculate = useCallback(() => {
        return count * 2;
    }, [count]);

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>Increment</button>
            <ExpensiveCalculation calculate={calculate} />
        </div>
    );
}

export default ParentComponent;
```

### 6. useMemo

`useMemo` 是用于返回一个记忆（缓存）的值的 Hook，可以防止在每次渲染时重新计算值，提高性能。

**示例代码：**

```jsx
import React, { useState, useMemo } from 'react';

function ExpensiveCalculation({ count }) {
    const result = useMemo(() => {
        console.log('Calculating...');
        return count * 2;
    }, [count]);

    return <div>Result: {result}</div>;
}

function ParentComponent() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>Increment</button>
            <ExpensiveCalculation count={count} />
        </div>
    );
}

export default ParentComponent;
```

### 7. useRef

`useRef` 是用于创建一个可以保存组件实例中变量的引用的 Hook。通常用于访问 DOM 元素或保存不触发重新渲染的变量。

**示例代码：**

```jsx
import React, { useRef } from 'react';

function FocusInput() {
    const inputRef = useRef(null);

    const focusInput = () => {
        inputRef.current.focus();
    };

    return (
        <div>
            <input ref={inputRef} type="text" />
            <button onClick={focusInput}>Focus Input</button>
        </div>
    );
}

export default FocusInput;
```

### 8. useLayoutEffect

`useLayoutEffect` 与 `useEffect` 类似，但它在所有 DOM 变更之后同步调用。适用于需要读取布局并同步重新渲染的情况。它会在浏览器绘制前运行。

**示例代码：**

```jsx
import React, { useLayoutEffect, useRef } from 'react';

function LayoutEffectExample() {
    const divRef = useRef(null);

    useLayoutEffect(() => {
        console.log(divRef.current.getBoundingClientRect());
    }, []);

    return <div ref={divRef}>Hello, useLayoutEffect!</div>;
}

export default LayoutEffectExample;
```



### 为什么要出现react hooks

很多情况下是来解决class component复杂的问题的 比如处理副作用 生命周期 state状态管理等等， 因为我确实不太懂class component具体怎么处理这些的， 所以就背下这些概念. 



### React 的组件之间的通信（props context 状态管理库redux ）

### 1. 父子组件通信

#### 通过 Props 传递数据

父组件可以通过 props 向子组件传递数据和回调函数。子组件通过接收 props 来获取从父组件传递过来的数据。

**示例代码：**

```jsx
// 父组件
import React from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
    const data = "Hello from Parent";

    return (
        <div>
            <ChildComponent message={data} />
        </div>
    );
}

export default ParentComponent;

// 子组件
import React from 'react';

function ChildComponent(props) {
    return (
        <div>
            <p>{props.message}</p>
        </div>
    );
}

export default ChildComponent;
```

### 2. 子父组件通信

#### 通过回调函数传递数据

子组件可以调用通过 props 传递的回调函数来向父组件发送数据。

**示例代码：**

```jsx
// 父组件
import React, { useState } from 'react';
import ChildComponent from './ChildComponent';

function ParentComponent() {
    const [data, setData] = useState('');

    const handleData = (childData) => {
        setData(childData);
    };

    return (
        <div>
            <ChildComponent onData={handleData} />
            <p>Data from child: {data}</p>
        </div>
    );
}

export default ParentComponent;

// 子组件
import React from 'react';

function ChildComponent(props) {
    const sendDataToParent = () => {
        props.onData('Hello from Child');
    };

    return (
        <div>
            <button onClick={sendDataToParent}>Send Data to Parent</button>
        </div>
    );
}

export default ChildComponent;
```

### 3. 兄弟组件通信

#### 通过共同父组件传递数据

兄弟组件可以通过共同的父组件来进行通信。父组件负责管理状态，并将状态通过 props 传递给兄弟组件。

**示例代码：**

```jsx
// 父组件
import React, { useState } from 'react';
import SiblingOne from './SiblingOne';
import SiblingTwo from './SiblingTwo';

function ParentComponent() {
    const [data, setData] = useState('');

    const handleData = (childData) => {
        setData(childData);
    };

    return (
        <div>
            <SiblingOne onData={handleData} />
            <SiblingTwo data={data} />
        </div>
    );
}

export default ParentComponent;

// 兄弟组件一
import React from 'react';

function SiblingOne(props) {
    const sendDataToParent = () => {
        props.onData('Hello from SiblingOne');
    };

    return (
        <div>
            <button onClick={sendDataToParent}>Send Data to SiblingTwo</button>
        </div>
    );
}

export default SiblingOne;

// 兄弟组件二
import React from 'react';

function SiblingTwo(props) {
    return (
        <div>
            <p>Data from SiblingOne: {props.data}</p>
        </div>
    );
}

export default SiblingTwo;
```

### 4. 使用 Context 进行跨层级通信

React Context 提供了一种不通过组件树逐层传递 props 就能在组件间共享值的方法。

**示例代码：**

```jsx
// 创建 Context
import React, { createContext, useContext, useState } from 'react';

const MyContext = createContext();

// 父组件
function ParentComponent() {
    const [data, setData] = useState('Hello from Context');

    return (
        <MyContext.Provider value={data}>
            <ChildComponent />
        </MyContext.Provider>
    );
}

export default ParentComponent;

// 子组件
function ChildComponent() {
    const contextData = useContext(MyContext);

    return (
        <div>
            <p>{contextData}</p>
        </div>
    );
}
```



### 5.  Redux 

通过一个具体的业务场景来详细说明如何在 React 应用中使用 Redux来管理用户信息（如 `uID` 和 `name`）

## 业务场景描述

假设我们正在开发一个简单的用户管理系统，其中需要：

1. **登录功能**：用户可以登录并查看他们的个人信息。
2. **用户信息存储**：存储用户的 `uID` 和 `name`。
3. **展示用户信息**：在应用的不同部分显示用户信息。

为了实现这一功能，我们将使用 Redux 来集中管理应用的状态。

## 步骤概述

1. **设置 store.js**。
2. **创建用户 Slice（使用 Redux Toolkit）**。
3. **配置 Provider 以将 Store 提供给 React 应用**。
4. **创建和连接 React 组件以访问和修改用户信息(useDispatch )**。

### 1. 设置 Redux Store

Redux Store 是 Redux 应用的核心，它保存着应用的所有状态。

#### 创建 Store 文件

在 `src` 目录下创建一个 `store.js` 文件：

```javascript
// src/store.js
import { configureStore } from '@reduxjs/toolkit';
import userReducer from './features/user/userSlice';

const store = configureStore({
  reducer: {
    user: userReducer,
  },
});

export default store;
```

**解释**：

- `configureStore` 是 Redux Toolkit 提供的一个简化配置 Store 的方法，它自动设置好 Redux DevTools 和中间件。
- `reducer` 字段接受一个对象，其中键是 state 的分片名称，值是相应的 reducer。这里我们创建了一个 `user` 的分片，由 `userReducer` 负责管理。

### 2. 创建用户 Slice

一个 slice 包含了 reducer 逻辑和相关的 actions。我们将创建一个用户 slice 来管理用户信息。

#### 创建 User Slice 文件

在 `src` 目录下创建一个 `features/user` 目录，并在其中创建 `userSlice.js` 文件：

```javascript
// src/features/user/userSlice.js
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  uID: null,
  name: '',
};

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    setUser: (state, action) => {
      state.uID = action.payload.uID;
      state.name = action.payload.name;
    },
    clearUser: (state) => {
      state.uID = null;
      state.name = '';
    },
  },
});
// actions
export const { setUser, clearUser } = userSlice.actions;
// 作为reducer
export default userSlice.reducer;
```

**解释**：

- `createSlice` 允许我们定义 slice 的名称、初始状态以及 reducers。
- `initialState` 定义了用户信息的初始状态，`uID` 和 `name` 初始为 `null` 和空字符串。
- `reducers` 定义了可以修改 state 的方法，这里有两个：
  - `setUser`：设置用户的 `uID` 和 `name`。
  - `clearUser`：清除用户信息，将 `uID` 和 `name` 重置。
- `userSlice.actions` 自动生成了对应的 action creators，我们将其导出以便在组件中使用。
- `userSlice.reducer` 是生成的 reducer 函数，我们将在 Store 中使用它。

### 3. 配置 Provider 以将 Store 提供给 React 应用

要使 Redux Store 可用于整个 React 应用，需要使用 `Provider` 组件将 Store 提供给组件树。

#### 修改 `index.js`

```javascript
// src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import store from './store';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Provider store={store}>
    <App />
  </Provider>
);
```

**解释**：

- `Provider` 组件来自 `react-redux`，用于将 Redux Store 提供给 React 组件树。
- 将 `store` 作为 `Provider` 的 `store` 属性传递。

### 4. 创建和连接 React 组件以访问和修改用户信息

#### 4.1 创建 Login 组件

```javascript
// src/features/user/Login.js
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { setUser } from './userSlice';

const Login = () => {
  const dispatch = useDispatch(); //useDispatch
  const [uID, setUID] = useState('');
  const [name, setName] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    if (uID && name) {
      dispatch(setUser({ uID, name })); //分发action
      setUID('');
      setName('');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>用户 ID:</label>
        <input
          type="text"
          value={uID}
          onChange={(e) => setUID(e.target.value)}
          required
        />
      </div>
      <div>
        <label>姓名:</label>
        <input
          type="text"
          value={name}
          onChange={(e) => setName(e.target.value)}
          required
        />
      </div>
      <button type="submit">登录</button>
    </form>
  );
};

export default Login;
```

**解释**：

- 使用 `useState` 来管理表单输入的本地状态。
- 使用 `useDispatch` 获取 `dispatch` 方法，以便分发 actions。
- 在表单提交时，验证输入并使用 `dispatch(setUser({ uID, name }))` 将用户信息存储到 Redux Store 中。

#### 4.2 创建 UserInfo 组件

```javascript
// src/features/user/UserInfo.js
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { clearUser } from './userSlice';

const UserInfo = () => {
  const dispatch = useDispatch();
  const user = useSelector((state) => state.user); //useSelector从Store 中获取user状态。

  if (!user.uID) {
    return <p>用户未登录</p>;
  }

  const handleLogout = () => {
    dispatch(clearUser());
  };

  return (
    <div>
      <h2>用户信息</h2>
      <p>用户 ID: {user.uID}</p>
      <p>姓名: {user.name}</p>
      <button onClick={handleLogout}>登出</button>
    </div>
  );
};

export default UserInfo;
```

**解释**：

- 使用 `useSelector` 从 Redux Store 中获取 `user` 状态。
- 如果 `uID` 为空，显示“用户未登录”。
- 如果用户已登录，显示用户信息，并提供登出按钮，通过 `dispatch(clearUser())` 清除用户信息。

#### 5.3 修改 App 组件

将 `Login` 和 `UserInfo` 组件集成到主应用中。

```javascript
// src/App.js
import React from 'react';
import Login from './features/user/Login';
import UserInfo from './features/user/UserInfo';

function App() {
  return (
    <div className="App">
      <h1>用户管理系统</h1>
      <Login />
      <UserInfo />
    </div>
  );
}

export default App;
```



### 5. 进一步优化和扩展

以上是一个基础的 Redux 配置示例，用于存储和管理用户信息。根据实际需求，你可以进一步扩展，例如：

- **异步操作**：使用 `createAsyncThunk` 处理异步请求，如从服务器获取用户信息。
- **持久化 Store**：使用中间件如 `redux-persist` 将 Store 持久化到 `localStorage` 或 `sessionStorage`。
- **更多的 Slice**：根据应用的复杂性，创建更多的 slice 来管理不同的状态。

#### 5.1 添加异步操作示例

假设我们需要从服务器获取用户信息，可以使用 `createAsyncThunk`。

```javascript
// src/features/user/userSlice.js
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

// 异步获取用户信息的 thunk
export const fetchUser = createAsyncThunk('user/fetchUser', async (uID) => {
  const response = await fetch(`/api/users/${uID}`);
  if (!response.ok) {
    throw new Error('网络响应错误');
  }
  const data = await response.json();
  return data; // 假设返回的数据包含 { uID, name }
});

const initialState = {
  uID: null,
  name: '',
  status: 'idle', // 'idle' | 'loading' | 'succeeded' | 'failed'
  error: null,
};

const userSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    setUser: (state, action) => {
      state.uID = action.payload.uID;
      state.name = action.payload.name;
    },
    clearUser: (state) => {
      state.uID = null;
      state.name = '';
      state.status = 'idle';
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchUser.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchUser.fulfilled, (state, action) => {
        state.status = 'succeeded';
        state.uID = action.payload.uID;
        state.name = action.payload.name;
      })
      .addCase(fetchUser.rejected, (state, action) => {
        state.status = 'failed';
        state.error = action.error.message;
      });
  },
});

export const { setUser, clearUser } = userSlice.actions;

export default userSlice.reducer;
```

**解释**：

- `fetchUser` 是一个异步 thunk，用于从服务器获取用户信息。
- 在 `extraReducers` 中处理 `fetchUser` 的不同状态（`pending`、`fulfilled`、`rejected`）。
- 更新 `status` 和 `error` 以反映异步操作的状态。

#### 8.2 在组件中使用异步操作

```javascript
// src/features/user/Login.js
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { fetchUser, setUser } from './userSlice';

const Login = () => {
  const dispatch = useDispatch();
  const [uID, setUID] = useState('');
  const [name, setName] = useState('');
  const userStatus = useSelector((state) => state.user.status);
  const userError = useSelector((state) => state.user.error);

  const handleSubmit = (e) => {
    e.preventDefault();
    if (uID) {
      dispatch(fetchUser(uID));
    }
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <div>
          <label>用户 ID:</label>
          <input
            type="text"
            value={uID}
            onChange={(e) => setUID(e.target.value)}
            required
          />
        </div>
        <button type="submit">登录</button>
      </form>
      {userStatus === 'loading' && <p>正在登录...</p>}
      {userStatus === 'failed' && <p>错误: {userError}</p>}
    </div>
  );
};

export default Login;
```

**解释**：

- 用户输入 `uID` 并提交后，触发 `fetchUser` 异步操作。
- 根据 `user.status` 显示不同的状态信息。

### 6. 总结

通过以上步骤，我们完成了一个简单的 React 应用，使用 Redux 和 `react-redux` 来集中管理用户信息。以下是关键点总结：

1. **Store 配置**：使用 Redux Toolkit 的 `configureStore` 简化了 Store 的配置。
2. **Slice 创建**：使用 `createSlice` 定义了 state 和 reducer，自动生成了 action creators。
3. **Provider 使用**：通过 `Provider` 组件将 Store 提供给 React 应用。
4. **组件连接**：使用 `useSelector` 和 `useDispatch` 连接组件与 Redux Store，实现状态的读取和修改。
5. **异步操作**：使用 `createAsyncThunk` 处理异步逻辑，如从服务器获取用户信息。

   



### React的Fiber

Fiber 是 React 的协调算法,使得 React 能够更好地管理复杂应用中的渲染性能问题

在 之前的版本中，协调算法（reconciliation）是**同步**的，也就是说，一旦开始渲染一个组件树，React 会阻塞整个线程，直到渲染完成。如果组件树很大，或者渲染过程很复杂，可能会导致性能问题，尤其是在需要频繁更新 UI 的应用中，这可能会导致浏览器卡顿或掉帧。

React Fiber 解决了这一问题，通过将渲染工作**分割成多个小任务**，允许 React 在空闲时间段内完成这些任务，从而实现更平滑、更高效的用户界面更新。

三个特点: 

1. **可中断渲染**：  
传统的 React 是同步渲染的，一旦开始更新组件，直到整个更新结束才能响应其他任务。这可能会导致页面卡顿，尤其是遇到复杂更新时。React Fiber 改进了这一点，它将渲染任务分成多个小的工作单元，并且每完成一个小任务后，它会检查是否有更重要的任务需要处理。比如，用户的输入或者动画更新。如果有更高优先级的任务，Fiber 会暂时中断当前的渲染，优先处理那些任务，等到空闲时再继续未完成的渲染工作。这样，用户不会感到页面被卡住。
2. **优先级调度**：  
Fiber 让 React 可以给不同的任务设定优先级。举个例子，像用户点击按钮、输入文本这些交互性操作，优先级会很高，因为用户需要及时的反馈。而其他一些数据更新、网络请求等操作优先级会低一些，可以稍后再处理。这种优先级调度机制确保了 React 先处理那些最重要的事情，让用户感觉应用更加灵活和快速。
3. **阶段划分**：
   Fiber 将渲染过程划分为两个阶段：
   - **渲染阶段（render）**：这是任务的调度和协调阶段，在这一阶段，React 会构建更新的 UI 树。这一阶段是可以被打断的。
   - **提交阶段 (commit)**：一旦渲染完成，React 会将更新提交到真实 DOM 上。这一阶段是同步的，不能被打断。











## TS

#### interface 和 type

 都定义对象结构

1. 都可以extends

```typescript
interface Animal {
  name: string;
}
interface Dog extends Animal {
  breed: string;
}
type AnimalType = {
  name: string;
};
type DogType = AnimalType & {
  breed: string;
};
```

2.type 可以而 interface 不行

type 可以声明基本类型别名，联合类型，元组等类型

```typescript
type Pet = Dog | Cat // 联合类型
type x = 'a' | 'b' | 'c' 
```

3. interface 能够**声明合并**

   ```
   interface User {
     name: string
     age: number
   }
   
   interface User {
     sex: string
   }
   
   /*
   User 接口为 {
     name: string
     age: number
     sex: string 
   }
   */
   ```

   

​	













# 理论

### 输入google.com 发生了什么

1. www.google.com  通过dns 解析 转换成对应的IP地址

 2. 建立TCP连接 该IP地址收到请求后 与 客户端发生三次握手进行连接(C => S SYN 包 S=>C SYN包 ACK包  C=>S ACK包 )
 3. TCP连接建立后 客户端向服务端发起http请求(或者https) 和请求方式(get, post... 这里是get) 
  4. 服务端收到请求后返回 HTML、CSS、JavaScript 文件，以及其他资源（如图像、视频等）。
  5. 客户端接受后浏览器进行渲染, HTML建立DOM树
  6. 渲染完毕后 如果没有持续的通信请求 进行四次挥手关闭连接（C => S (FIN 包) S=>C(ACK 包 收到关闭请求) S=>C(FIN 包 表示数据已经发完) C=>S(ACK 收到关闭请求 并关闭连接)）

**为什么需要3次不是两次** (C=>S SYN S=>C ACK)

这样未经C端确认可能会导致过期的连接 在最后C端再向S端发送ACK可以保证现在的连接是有效的 确实需要连接



### 简述TCP建立连接和断开连接

### TCP 建立连接（三次握手）

TCP建立连接的过程称为三次握手（Three-Way Handshake），步骤如下：

1. **第一次握手（SYN）**：
   - 客户端发送一个SYN（synchronize）标志位为1的TCP报文，指示要建立连接，并发送一个初始序列号（Sequence Number，简称SEQ），记作 `x`。
   - 报文段格式：`SYN=x`

2. **第二次握手（SYN-ACK）**：
   - 服务器接收到SYN报文后，返回一个SYN-ACK报文。这个报文中包含服务器的初始序列号 `y`，并对客户端的序列号 `x` 进行确认（ACKnowledge），其确认号为 `x+1`。
   - 报文段格式：`SYN=y, ACK=x+1`

3. **第三次握手（ACK）**：
   - 客户端接收到服务器的SYN-ACK报文后，再发送一个确认报文（ACK），确认号为 `y+1`，序列号为 `x+1`。此时，客户端和服务器都进入连接已建立（ESTABLISHED）状态。
   - 报文段格式：`ACK=y+1`

### TCP 断开连接（四次挥手）

TCP断开连接的过程称为四次挥手（Four-Way Handshake），步骤如下：

1. **第一次挥手（FIN）**：
   - 客户端发送一个FIN（finish）标志位为1的TCP报文，指示要关闭连接，并发送一个序列号 `u`。
   - 报文段格式：`FIN=u`

2. **第二次挥手（ACK）**：
   - 服务器接收到FIN报文后，发送一个确认报文（ACK），确认号为 `u+1`，表示已经接收到关闭连接的请求，但仍然可以继续发送未完成的数据。
   - 报文段格式：`ACK=u+1`
   - 此时，服务器进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。

3. **第三次挥手（FIN）**：
   - 服务器发送完所有数据后，发送一个FIN报文，指示可以关闭连接，并发送一个序列号 `v`。
   - 报文段格式：`FIN=v`
   - 此时，服务器进入LAST_ACK状态。

4. **第四次挥手（ACK）**：
   - 客户端接收到服务器的FIN报文后，发送一个确认报文（ACK），确认号为 `v+1`，表示已经接收到关闭连接的请求。
   - 报文段格式：`ACK=v+1`
   - 此时，客户端进入TIME_WAIT状态，等待一定时间（通常为2倍的MSL，Maximum Segment Lifetime）以确保服务器接收到确认报文后再进入CLOSED状态。
   - 服务器在接收到确认报文后直接进入CLOSED状态。

### 图示

#### 三次握手

```
Client                  Server
  |     SYN=x            |
  |--------------------->|
  |                      |
  |     SYN=y, ACK=x+1   |
  |<---------------------|
  |                      |
  |     ACK=y+1          |
  |--------------------->|
  |                      |
```

#### 四次挥手

```
Client                  Server
  |     FIN=u            |
  |--------------------->|
  |                      |
  |     ACK=u+1          |
  |<---------------------|
  |                      |
  |     FIN=v            |
  |<---------------------|
  |                      |
  |     ACK=v+1          |
  |--------------------->|
  |                      |
```

通过三次握手，客户端和服务器之间建立了可靠的连接。通过四次挥手，确保双方都能可靠地关闭连接并释放资源。这些机制是TCP协议提供可靠传输的重要保障。



### 网络请求状态码

### 1xx：信息性状态码
- **100 Continue**：请求已接收，继续处理。
- **101 Switching Protocols**：服务器正在切换协议。

### 2xx：成功状态码
- **200 OK**：请求成功，返回所请求的数据。
- **201 Created**：成功请求并创建了新资源（如 POST 请求）。
- **204 No Content**：请求成功，但没有返回内容。

### 3xx：重定向状态码
- **301 Moved Permanently**：请求的资源已永久移动到新 URL(用于永久性改变 URL，影响 **SEO** 和用户访问)
- **302 Found**：请求的资源临时移动到其他 URL(原URL有效)
- **304 Not Modified**：资源未修改，客户端可以使用缓存版本，减少不必要的网络请求,是一个缓存优化

### 4xx：客户端错误状态码
- **400 Bad Request**：请求无效，服务器无法理解。开发时**借口参数写错了**
- **401 Unauthorized**：请求未授权，需进行身份验证。用户**没登录**
- **403 Forbidden**：服务器拒绝请求，客户端无权访问。**权限**不足（普通用户/管理员） IP黑名单
- **404 Not Found**：请求的资源未找到。

### 5xx：服务器错误状态码
- **500 Internal Server Error**：服务器发生意外错误。
- **502 Bad Gateway**：作为网关或代理的服务器接收到无效响应。
- **503 Service Unavailable**：服务器暂时无法处理请求（可能是维护中）





### URL 查询字符串（Query String）

#### 定义
查询字符串用于在 URL 中传递额外的参数，格式为 `?key1=value1&key2=value2`。

#### 组成
- **`?`**：开始查询字符串
- **`&`**：分隔多个参数
- **`=`**：连接键和值

#### 用途
- **搜索**：`https://example.com/search?query=javascript`
- **分页**：`https://example.com/articles?page=2&size=10`
- **排序和过滤**：`https://example.com/products?sort=price&filter=available`
- **追踪和分析**：`https://example.com/landing?utm_source=newsletter`

#### 处理查询字符串
**客户端**（JavaScript）：
```javascript
const params = new URLSearchParams(window.location.search);
const query = params.get('query');
```

**服务器端**（Node.js）：
```javascript
const querystring = require('querystring');
const params = querystring.parse(request.url.split('?')[1]);
```

#### URL 编码和解码
```javascript
const encoded = encodeURIComponent('a value with spaces');
const decoded = decodeURIComponent(encoded);
```

### 示例
```javascript
// 示例 URL: https://example.com/search?query=javascript&page=2
const url = new URL('https://example.com/search?query=javascript&page=2');
const params = new URLSearchParams(url.search);
console.log(params.get('query')); // 'javascript'
console.log(params.get('page')); // '2'
```



## 前端安全

#### XSS（跨站脚本攻击）

InnerHTML或者Document.write会不编码 比如在一个input里输入一段脚本，他就会直接执行这个脚本了

```html
<script>alert('XSS Attack!');</script>
```

#### CSRF

通过用户的身份在受信任网站上执行未授权的操作。

#### CSRF 攻击的工作原理

1. **用户在 A 网站上登录**：
   
   - 用户访问并登录到受信任的网站（A 网站），例如他们的银行或社交媒体账户。登录成功后，A 网站会在用户的浏览器中设置一个身份验证 Cookie，用于识别用户的登录状态。
   
2. **用户在浏览器中访问 B 网站**：
   - 用户在登录 A 网站之后，继续浏览其他网页。此时，用户访问了一个由攻击者控制的恶意网站（B 网站）。用户在 A 网站的登录会话仍然有效，因为身份验证 Cookie 仍然存储在用户的浏览器中。

3. **B 网站发起针对 A 网站的请求**：
   - B 网站的页面包含一个表单或脚本，自动向 A 网站发送一个请求。这可能是通过自动提交表单、AJAX 请求或嵌入图像、脚本等方式发送的。
   - 例如，B 网站的恶意页面可能包含如下代码，试图在用户不知情的情况下提交更改电子邮件地址的请求：

     ```html
     <form action="https://a-website.com/change-email" method="POST">
         <input type="hidden" name="email" value="attacker@example.com">
         <input type="submit" value="提交">
     </form>
     ```

     或者通过 JavaScript 自动提交该表单：

     ```html
     <img src="https://a-website.com/change-email?email=attacker@example.com" style="display:none;">
     ```

4. **浏览器携带 A 网站的 Cookie**：
   - 当用户浏览 B 网站时，B 网站的脚本或表单会自动向 A 网站发送请求。由于浏览器会自动附带所有相关的 Cookie（包括 A 网站的身份验证 Cookie），A 网站会认为这个请求是合法用户发起的。

5. **A 网站处理请求**：
   - A 网站在收到请求时，由于 Cookie 的存在，会认为这是用户的合法请求，并按照请求执行操作，例如更改用户的电子邮件地址、执行资金转账等。

### 关键点

- **身份验证 Cookie**：这是 CSRF 攻击的核心。浏览器会自动附带与域名相关的 Cookie，而不会验证请求的来源。这使得在不同网站间发送请求时，即使是在恶意网站 B 上发起的请求，浏览器也会携带 A 网站的 Cookie。
  
- **用户不知情**：CSRF 攻击不依赖于用户的主动点击，只需要用户登录并拥有有效的会话。恶意代码可以在用户不知情的情况下发送请求。

### 防止 CSRF 的措施

1. **使用 CSRF 令牌**：
   - 在每个表单请求中嵌入一个唯一的 CSRF 令牌，并在服务器端验证该令牌。攻击者无法从跨站请求中获取或伪造有效的 CSRF 令牌，这可以有效防止 CSRF 攻击。

2. **SameSite Cookie 属性**：
   - 设置 Cookie 的 `SameSite` 属性为 `Strict` 或 `Lax`，以限制 Cookie 只能在同源请求中发送。即使用户访问了恶意网站，恶意网站发起的跨站请求也不会包含用户的身份验证 Cookie。

3. **验证 HTTP 请求头**：
   - 检查 HTTP 请求的 `Origin` 和 `Referer` 头，确保请求来源是可信的。这种方法可以在某些情况下识别和阻止恶意请求。







### 为什么要阻止跨域? 有具体例子嘛?

跨域（CORS）是指浏览器从一个**源（域(`www.google.com`)、协议和端口）**请求资源时，资源位于另一个源。这种情况常常会遇到同源策略的限制。阻止跨域请求的主要目的是出于安全考虑，防止恶意网站从受信任的网站读取敏感信息。这种限制被称为同源策略（Same-Origin Policy）。

### 为什么要阻止跨域请求？

1. **保护用户数据**：防止恶意网站从另一个网站读取敏感数据（如用户的私人信息、浏览历史、会话数据等）。
2. **防止 CSRF 攻击**：防止跨站请求伪造（Cross-Site Request Forgery, CSRF）攻击，恶意网站通过用户的身份在受信任网站上执行未授权的操作。
3. **数据泄露**：防止数据泄露和未经授权的数据访问。

### 具体例子

#### 1. 保护用户数据

假设用户登录到银行网站 `https://bank.example.com` 并在该网站上处理个人银行事务。如果不阻止跨域请求，恶意网站 `https://evil.example.com` 可以通过脚本发送请求到 `https://bank.example.com` 并获取用户的敏感数据。

```html
<!-- 恶意网站的页面 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Evil Site</title>
    <script>
        fetch('https://bank.example.com/account-details', {
            credentials: 'include'
        })
        .then(response => response.json())
        .then(data => {
            console.log(data); // 读取用户的银行账户信息
        });
    </script>
</head>
<body>
    <h1>Welcome to Evil Site</h1>
</body>
</html>
```

#### 2. 防止 CSRF 攻击

假设用户已经登录到购物网站 `https://shop.example.com` 并且会话仍然有效。如果恶意网站 `https://evil.example.com` 发起一个请求，这个请求在用户的身份下运行，将会导致用户在不知情的情况下执行某些操作。

```html
<!-- 恶意网站的页面 -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Evil Site</title>
</head>
<body>
    <h1>Welcome to Evil Site</h1>
    <img src="https://shop.example.com/purchase?item=123&quantity=1" style="display:none;">
    <!-- 上面的请求将在用户不知情的情况下购买商品 -->
</body>
</html>
```

### 如何解决跨域问题？

虽然跨域请求被默认阻止，但有时需要跨域请求来访问不同域名下的资源。为了解决这个问题，CORS 规范提供了一种机制，允许服务器声明哪些源可以访问资源。

#### 使用 CORS

服务器可以在响应头中包含以下头信息来允许跨域请求：

```http
Access-Control-Allow-Origin: https://example.com
```

#### 示例代码

```javascript
// Node.js 服务器端示例，使用 Express.js
const express = require('express');
const app = express();

app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', 'https://example.com'); // 允许来自 https://example.com 的请求
    res.header('Access-Control-Allow-Methods', 'GET, POST'); // 允许的 HTTP 方法
    res.header('Access-Control-Allow-Headers', 'Content-Type'); // 允许的请求头
    next();
});

app.get('/data', (req, res) => {
    res.json({ message: 'This is CORS-enabled for example.com only!' });
});

app.listen(3000, () => {
    console.log('CORS-enabled web server listening on port 3000');
});
```

### 总结

- **阻止跨域请求**：保护用户数据，防止 CSRF 攻击和数据泄露。
- **CORS 机制**：允许服务器声明哪些源可以访问资源，以便在需要跨域请求时确保安全。

通过理解和正确配置 CORS，可以在保护安全的同时，允许合法的跨域请求，从而实现更灵活的 Web 应用。





### 浏览器是怎么进行渲染的

1. **解析 HTML，构建 DOM 树**：
   - 浏览器从上到下解析 HTML 文档，将各个 HTML 元素节点转化为 DOM（Document Object Model）树的节点。

2. **解析 CSS，构建 CSSOM 树**：
   - 解析 HTML 时，遇到 `<link>` 或 `<style>` 标签，浏览器会发起请求获取 CSS 文件或解析内联 CSS，构建 CSSOM（CSS Object Model）树。

3. **处理 JavaScript**：
   - 遇到 `<script>` 标签时，浏览器会下载并执行 JavaScript 脚本。
   - 默认情况下，脚本执行会阻塞 HTML 解析。使用 `async` 属性，脚本会异步加载并执行，不阻塞解析。使用 `defer` 属性，脚本会在 HTML 解析完成后执行。

4. **构建渲染树**：
   - 浏览器将 DOM 树和 CSSOM 树合并，生成渲染树。渲染树包含每个可见元素的视觉样式信息。

5. **布局（Layout）**：
   - 浏览器根据渲染树进行布局计算（也称为“回流”或“重排”），确定每个元素的几何位置和尺寸。

6. **绘制（Painting）**：
   - 布局完成后，浏览器将渲染树中的元素绘制到屏幕上，显示最终的页面。



### 堆空间和栈空间的区别

### 1. 分配和管理方式

- **栈空间**：
  - 栈空间由编译器自动分配和释放，用于存储局部变量、函数参数和函数调用的返回地址。
  - 栈的内存分配是连续的，内存释放是按照后进先出的顺序（LIFO）进行。
  - 栈上的内存分配速度快，因为只需调整栈指针即可。

- **堆空间**：
  - 堆空间由程序员手动分配和释放，用于动态分配内存（如使用 `malloc`、`calloc`、`realloc` 在 C/C++ 中，或 `new` 在 C++ 中，`new` 在 JavaScript 中）。
  - 堆的内存分配是非连续的，由操作系统或运行时库管理。
  - 堆上的内存分配速度相对较慢，因为需要在自由存储区查找足够大的空闲块，并可能涉及到复杂的内存管理策略（如垃圾回收）。

### 2. 存储内容

- **栈空间**：
  - 存储函数调用的上下文，包括局部变量、函数参数、返回地址等。
  - 栈上的变量在函数调用结束时自动释放。

- **堆空间**：
  - 存储动态分配的内存块，如动态数组、链表、树等复杂数据结构。
  - 堆上的内存需要程序员显式释放，否则会导致内存泄漏。

### 3. 访问方式

- **栈空间**：
  - 变量通过栈帧偏移量直接访问，访问速度快。
  - 栈上的内存生命周期受函数调用约束。

- **堆空间**：
  - 变量通过指针间接访问，访问速度相对较慢。
  - 堆上的内存生命周期由程序员控制，可跨越函数调用。

### 4. 内存限制

- **栈空间**：
  - 栈空间通常较小，受操作系统的限制。
  - 过多的递归调用或分配过大的局部变量可能导致栈溢出（stack overflow）。

- **堆空间**：
  - 堆空间相对较大，但仍受系统可用内存的限制。
  - 动态分配过多内存可能导致内存耗尽（out of memory）。

### 总结

- **栈空间**：用于存储局部变量和函数调用，分配和释放速度快，但内存容量较小，自动管理。
- **堆空间**：用于动态内存分配，适合存储复杂数据结构，内存容量较大，但需要手动管理，分配和释放速度相对较慢。



### HTTP 和 HTTPS 的区别

**HTTP**：是一种不安全的协议，数据以明文形式传输 默认在80端口 更快 不需要SSL/TSL证书

**HTTPS**： 加密  默认在443端口 需要SSL/TSL证书

#### HTTP (HyperText Transfer Protocol)
- **不安全**：HTTP 协议的数据在传输过程中是明文的，容易被窃听、篡改。
- **端口**：默认使用端口 80。
- **加密**：不使用加密机制。
- **证书**：不需要证书。

#### HTTPS (HyperText Transfer Protocol Secure)
- **安全**：HTTPS 在 HTTP 的基础上增加了 SSL/TLS 协议，对数据进行加密，确保数据的机密性和完整性。
- **端口**：默认使用端口 443。
- **加密**：使用 SSL/TLS 协议进行加密。
- **证书**：需要数字证书来验证服务器的身份。

### 加密的工作原理

HTTPS 使用 SSL/TLS 协议来加密数据。其工作原理可以概括为以下几个步骤：

1. **客户端发送请求**：
   - 客户端（如浏览器）请求 HTTPS 连接到服务器，并发送一个随机数（ClientHello），同时提供客户端支持的加密算法列表。

2. **服务器响应**：
   - 服务器发送服务器证书（包含公钥）和加密算法选择（ServerHello），并生成一个随机数。

3. **客户端验证服务器证书**：
   - 客户端验证服务器证书的有效性，如果证书可信，则继续。

4. **生成会话密钥**：
   - 客户端生成一个新的随机数，并使用服务器的公钥对该随机数进行加密，发送给服务器。服务器使用自己的私钥解密这个随机数。
   - 现在客户端和服务器都拥有了三个随机数，双方使用这三个随机数生成会话密钥（对称加密密钥）。

5. **数据加密传输**：
   - 客户端和服务器使用生成的会话密钥对数据进行加密和解密。

### 常用的加密算法

#### 对称加密算法

对称加密算法使用同一个密钥进行加密和解密，速度快，适用于大量数据加密。

- **AES (Advanced Encryption Standard)**：一种广泛使用的对称加密算法，支持 128 位、192 位和 256 位密钥长度。
- **DES (Data Encryption Standard)**：一种较旧的对称加密算法，安全性较低，已被 AES 替代。
- **3DES (Triple DES)**：对 DES 的改进，使用三个不同的密钥进行三次加密，安全性较 DES 高，但速度较慢。

#### 非对称加密算法

非对称加密算法使用一对密钥（公钥和私钥）进行加密和解密，适用于密钥交换和数字签名。

- **RSA (Rivest–Shamir–Adleman)**：一种广泛使用的非对称加密算法，适用于密钥交换和数字签名。
- **ECC (Elliptic Curve Cryptography)**：一种基于椭圆曲线数学的非对称加密算法，提供更高的安全性和更小的密钥长度。

#### 哈希算法

哈希算法用于生成数据的唯一固定长度哈希值，常用于数据完整性校验和数字签名。

- **SHA-256 (Secure Hash Algorithm 256-bit)**：SHA-2 家族的一种，生成 256 位的哈希值，广泛用于数据完整性校验和数字签名。
- **MD5 (Message Digest Algorithm 5)**：一种较旧的哈希算法，生成 128 位的哈希值，已被认为不安全。

### HTTPS 连接示例代码

以下是使用 Node.js 实现一个简单的 HTTPS 服务器的示例代码：

```javascript
const https = require('https');
const fs = require('fs');

// 读取 SSL 证书
const options = {
  key: fs.readFileSync('server.key'), // 私钥
  cert: fs.readFileSync('server.crt') // 证书
};

// 创建 HTTPS 服务器
https.createServer(options, (req, res) => {
  res.writeHead(200);
  res.end('Hello, HTTPS!\n');
}).listen(443);

console.log('HTTPS server running on port 443');
```

### 结论

- **HTTP**：不安全的明文传输协议，使用端口 80。
- **HTTPS**：安全的加密传输协议，使用端口 443，需要 SSL/TLS 证书。
- **常用加密算法**：包括对称加密（AES）、非对称加密（RSA、ECC）和哈希算法（SHA-256）。

通过使用 HTTPS，可以确保客户端和服务器之间传输的数据的机密性、完整性和真实性。



Webkit



## HTTP 1.0 1.1 2.0 3.0

HTTP协议是浏览器与服务器之间通信的协议

**无状态**：HTTP是无状态协议，这意味着每次请求都是独立的，服务器不会自动记住之前请求的任何信息。为了维持状态（如用户登录），通常使用**Cookies**、**Sessions**或**Token**来存储用户信息。

### HTTP 1.0

**主要特点**：
1. **无状态连接**：每个请求/响应对都是独立的，服务器不会保留前后请求的上下文。
2. **每个请求一个连接**：客户端和服务器之间的每次请求和响应需要建立一个新的 TCP 连接。
3. **基本功能**：提供基本的 GET、POST 和 HEAD 方法。

**缺点**：
- 连接开销大：每次请求都需要建立和关闭连接，效率低下。
- 缺乏持久连接：无法在同一连接中发送多个请求，导致高延迟。

### HTTP 1.1

**主要改进**：
1. **持久连接**：默认启用了持久连接（Connection: keep-alive），允许在一个 TCP 连接中发送多个请求和响应。
2. **管道化**：允许在发送前一个响应之前发送多个请求，从而减少了等待时间。
3. **额外的缓存控制**：引入了更多的缓存控制头，例如 ETag 和 If-Modified-Since。
4. **带宽优化**：引入了分块传输编码（Chunked Transfer Encoding），允许服务器在不提前知道响应内容长度的情况下发送数据。
5. **更多方法**：增加了 PUT、DELETE、OPTIONS 等方法。
6. **虚拟主机支持**：通过 Host 头字段支持同一 IP 地址上的多个域名。

**缺点**：
- 虽然引入了持久连接和管道化，但由于队头阻塞(一个 TCP 连接只能处理一个请求)

### HTTP 2.0

**发布年份**：2015（RFC 7540）

**主要改进**：
1. **二进制协议**：将文本协议改为二进制协议，提高了解析效率和灵活性。
2. **多路复用**：**一个 TCP 连接**同时**发送多个请求和响应**
3. **头部压缩**：使用 HPACK 算法对头部进行压缩，减少了带宽消耗。
4. **服务器推送**：服务器可以主动向客户端推送资源，减少延迟。
5. **流优先级**：允许客户端指定流的优先级，以优化资源加载顺序。

**缺点**：
- 仍然依赖于单个 TCP 连接，存在潜在的队头阻塞问题，

### HTTP 3.0

**发布年份**：正在制定中（基于 QUIC，IETF 工作组正在进行标准化）

**主要改进**：
1. **基于 QUIC**：使用基于 UDP 的 QUIC 协议取代 TCP，提高连接建立速度和传输效率。
2. **移除队头阻塞**：QUIC 协议内置多路复用和流控制，完全消除队头阻塞问题。
3. **更快的连接建立**：使用 0-RTT 和 1-RTT 握手机制，显著减少连接建立时间。
4. **内置加密**：所有 QUIC 连接默认都是加密的，增强了安全性。

**优点**：
- 在高延迟和高丢包率的网络环境下性能显著提升。
- 更快的连接建立和数据传输。

### 总结

- **HTTP 1.0**：每个请求一个连接，无持久连接，效率低。
- **HTTP 1.1**：引入持久连接和管道化，多请求一个连接，性能有所提升。
- **HTTP 2.0**：二进制协议、多路复用、头部压缩和服务器推送，显著提升性能。
- **HTTP 3.0**：基于 QUIC，移除队头阻塞，更快的连接建立和传输，增强的安全性。









## CDN

内容分发网络（Content Delivery Network，简称 CDN）是一种通过在全球范围内分布多个服务器节点，将内容缓存到离用户更近的服务器上，从而加速网站内容传输的技术。CDN 的主要目标是提高内容的访问速度、减少服务器负载和增强网站的可用性。

### CDN 的工作原理

CDN 的工作原理可以概括为以下几个步骤：

1. **用户请求内容**：当用户访问某个网站时，浏览器会向网站服务器发送请求。
2. **请求重定向**：CDN 根据用户的地理位置和当前的网络流量，将请求重定向到离用户最近的 CDN 节点。
3. **内容缓存**：CDN 节点检查是否缓存了请求的内容。如果有缓存，直接将内容返回给用户；如果没有缓存，则向源服务器请求内容，并将其缓存以备将来使用。
4. **内容传输**：CDN 节点将内容传输给用户，同时在缓存中保存副本，以便处理未来的请求。

### CDN 的优点

1. **加速内容传输**：通过将内容缓存到离用户更近的节点，可以显著减少延迟，加速内容的加载速度。
2. **减轻服务器负载**：CDN 节点承担了大量的内容请求，减轻了源服务器的压力，从而提高了服务器的响应速度和稳定性。
3. **提高可用性和可靠性**：CDN 节点分布在全球多个地方，即使某些节点出现故障，其他节点仍然可以继续提供服务，确保网站的高可用性。
4. **增强安全性**：CDN 可以提供 DDoS 防护、Web 应用防火墙（WAF）等安全功能，保护网站免受恶意攻击。

### CDN 的技术实现

CDN 的技术实现通常包括以下几个关键组件：

1. **缓存服务器**：分布在全球各地的服务器节点，用于缓存和提供内容。
2. **负载均衡**：将用户请求分配到最合适的 CDN 节点，确保最佳性能和资源利用率。
3. **内容缓存策略**：如 TTL（Time To Live）设置、缓存失效策略等，控制内容的缓存和更新。
4. **网络监控和分析**：实时监控网络流量、性能和健康状态，确保 CDN 的高效运行。

### 结论

CDN 是一种重要的技术，通过在全球范围内分布多个服务器节点，将内容缓存到离用户更近的服务器上，从而加速网站内容传输、减轻服务器负载、提高网站的可用性和安全性。无论是静态资源还是动态内容，CDN 都能显著提升用户体验，是现代网站和应用程序优化的关键技术之一。



### 游览器最大能保持多少个tcp连接

6个 根据浏览器限制的





##### 线程和进程

Process: 进程是操作系统分配资源的基本单位.	OS支持同时运行多个进程，这就是多任务处理  开销较大

Thread:  线程是进程内的一个执行单元，是操作系统能够进行运算调度的最小单位。它被包含在进程中，是进程中实际运行工作的部分。

1. **资源共享**：同一进程内的线程共享进程的资源（如内存空间）。这使得线程间的通信和数据共享更容易。
2. **开销较小**：相比进程，线程的创建、销毁和切换的开销更小。
3. **多线程**：一个进程可以有一个或多个线程。多线程可以实现在同一进程内的并行(parallel)操作。







